\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage{xspace}
\usepackage{tabu}
\usepackage[%
  hyperindex,%
  plainpages=false,%
  pdfusetitle]{hyperref}
\usepackage[all]{hypcap}
\usepackage{cite}
\usepackage{booktabs}
\usepackage{url}
\usepackage{listings}
\usepackage{enumitem}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{tikz}
\usetikzlibrary{positioning,shapes.geometric, arrows,automata, decorations.pathreplacing, calc}
\usepackage{pgf}
\usepackage{slantsc}
\usepackage{geometry}
\usepackage{amssymb}
\usepackage{subcaption}
\usepackage{float}


\usepackage[%disable,%
  colorinlistoftodos,%
  color=cyan!50!white,%
  bordercolor=cyan!50!black]{todonotes}

%%%%%%%%%%%% Colors 
%% a somewhat friendly scheme for 5 different colors 
\definecolor{g1}		{RGB}{215,25,28} % a kind of red
\definecolor{g2}		{RGB}{253,174,97} % a kind of orange
\definecolor{g3}		{RGB}{255,255,191} % a kind of yellow
\definecolor{g4}		{RGB}{171,217,233} % a kind of light blue 
\definecolor{g5}		{RGB}{44,123,182} % a kind of dark blue 

\definecolor{gr1}		{RGB}{250, 250, 250}
\definecolor{gr2}		{RGB}{229, 229, 229} % some grey

% color of interpolants
\definecolor{grey}{RGB}{200,200,200}

%color for pictures
\colorlet{outlineblue}		{g5}
\colorlet{fillblue}			{g4}
\colorlet{darkback}			{gr2}
\colorlet{lightback}		{gr1}
\colorlet{stmtcolor}		{gr2} %default statement color
\colorlet{subgraphcolor}	{g3} %default statement color


%%%%%%%%%%%% Setup
\newtheorem{name}{Printed output}
\newtheorem{mydef}{Definition}

\hypersetup{
colorlinks=true,        % false: boxed links; true: colored links
linkcolor=g1,        % color of internal links
citecolor=g1,        % color of links to bibliography
filecolor=g1,        % color of file links
urlcolor=g1          % color of external links
}


\lstdefinestyle{boogie}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  xleftmargin=\parindent,
  showstringspaces=false,
  basicstyle=\footnotesize\ttfamily,
  numbers=left,
  xleftmargin=.6cm
}

\lstset{escapechar=@,style=boogie}

%%%%%%%%%%%% Comments
\newif\iffinal
%\finaltrue % comment out to remove comments 
 
\iffinal
\newcommand\mycom[1]{}
\else
\newcommand\mycom[1]{#1}
\overfullrule=1mm
\fi
\setlength\parindent{0pt}

\newcommand{\WidestEntry}{$\psi_{global}$}%
\newcommand{\SetToWidest}[1]{\makebox[\widthof{\WidestEntry}]{$#1$}}%

\newcommand{\jw}[1]{\mycom{\todo[color=blue!40,inline]{\small JW: #1}}}
\newcommand{\jwl}[1]{\mycom{\todo[color=blue!40,inline,caption={Beschreibung},nolist]{\small #1}}}
\newcommand{\dd}[1]{\mycom{\todo[color=orange!40,inline]{\small DD: #1}}}
\newcommand{\ddl}[1]{\mycom{\todo[color=orange!40,inline,caption={Beschreibung},nolist]{\small #1}}}

\newcommand{\all}[1]{\mycom{\todo[color=green!40,inline]{\small #1}}}
\newcommand{\meta}[1]{\mycom{\todo[color=blue!10,inline,caption={Beschreibung},nolist]{\setlist{nolistsep}\small #1}}}
\newcommand{\xxx}{\mycom{\stfootcol{Placeholder}{blue!20}\xspace}}
\newcommand{\cn}{\mycom{\stfootcol{Cite}{blue!20}\xspace}}


%%%%%%%%%%%% Actual content
\begin{document}
	\newcommand{\HorizontalLine}{\rule{\linewidth}{0.3mm}}
	
	\title{ \HorizontalLine \\ \textbf{Interprocedual and Interpolating \\ Property Directed Reachability in \textsc{Ultimate}} \HorizontalLine}
	

	
	\author{Jonas Werner \\ Dr. Daniel Dietsch}


	
	\date{} 
	
	\maketitle
	
	\begin{abstract}
	In a previous project we implemented a library using PDR for software verification in the program analysis framework ULTIMATE. However \jw{...}
	\end{abstract}
	
	
	%-------------------------------------------------%
	\section{Introduction}
	%-------------------------------------------------%
	
	Property Directed Reachability (PDR) was first devised as a hardware verification paradigm by Aaron Bradley \cite{DBLP:conf/vmcai/Bradley11}. It however showed potential as a software verification method as well.
	In the course of my 2018 Bachelor's Thesis we devised a method of using Property Directed Reachability on software in the software analysis framework \textsc{Ultimate} \cite{Zitat02}. \\
	Our approach was based on the technique described by Lange et al \cite{DBLP:conf/date/WelpK13}. \\ The implementation however worked solely on intraprocedual programs, meaning programs containing more than one procedure could not be analysed. \\
	Furthermore our implementation did not make use of interpolants which broaden the state space covered by blocked proof-obligations. \\
	This project aims at expanding PDR with both interprocedual analysis capabilities and usage of interpolants. \par
	
    This paper is structured as follows, firstly we will give some background definition of interprocedual program analysis and interpolants, then we will introduce the functionality of our PDR library in Ultimate. In chapter 4 we propose a way of using PDR on programs containing multiple procedures. Chapter 6 discusses our usage of interpolants. Lastly Chapter 7 will provide some benchmarks showing the effectiveness of interprocedual PDR.
    
    \pagebreak
	
	%-------------------------------------------------%
	\section{Background}
	%-------------------------------------------------%
	In this section we will give preliminary definitions on what interprocedual programs are and what interpolants we use.
	
    
    \newcommand{\tf}{\ensuremath{\varphi}\xspace}
    \newcommand{\ctf}{\ensuremath{\widehat{\varphi}}\xspace}
    \newcommand{\invars}{\ensuremath{In}\xspace}
    \newcommand{\outvars}{\ensuremath{Out}\xspace}
    \newcommand{\auxvars}{\ensuremath{Aux}\xspace}
	
	\subsection{Control Flow Graphs}	
	Given a program we need a way to model its control flow to check whether given error states can be reachable or not, for that we introduce control flow graphs.
	
	\begin{mydef}
	Each program variable $(PV)$ $x$, is mapped to a tuple $(proc, tv, c, c')$ that consists of: 
		\begin{itemize}
			\item A label $proc$ that assigns the name of the corresponding procedure in which the program variable occurs. 
			%If the program variable is a global variable, $proc = null$
			\item A termvariable (TV) $x_i$ that is used in term operations and SMT calls.
			\item A constant $c_x$
			\item A primed constant $c_x'$
		\end{itemize}
	\end{mydef}
	For example, assume we have the local variable $x$ that is used in procedure $foo$. $x$ is mapped to the tuple $(foo, x_0, c_x, c'_x)$. 
	%\begin{itemize}
	%	\item $proc(x) = foo$
	%	\item $tv(x) = t_x$
	%	\item constant of x: $c_x$
	%	\item primed constant of x: $c'_x$
	%\end{itemize} 
	
	\begin{mydef}
		A predicate $P = (V, \phi, \widehat{\phi})$ is a tuple consisting of: 
		\begin{itemize}
			\item A set of program variables $V$
			\item A formula $\phi$ over the termvariables of the program variables in $V$
			\item A formula $\widehat{\phi}$ which is the closed formula of $\phi$ where every termvariable is replaced by the corresponding program variable unprimed constant.
		\end{itemize}
	\end{mydef}
	

    \begin{mydef}
        A transformula (TF) is a tuple $\psi = (\invars, \outvars, \auxvars, \tf, \ctf)$ with 
        \begin{itemize}
          \item $\invars : x \rightarrow x_i$ is a mapping from program variables to unprimed termvariables called the in-variables
          \item $\outvars : x \rightarrow x_i'$ is a mapping from program variables to primed termvariables called the out-variables
          \item $\auxvars: \{ v_i \}$ is a set of termvariables $v_i$ that only exist in the context of this transformula called the aux-variables,
          \item $\tf$ is a formula over termvariables from $\invars$, $\outvars$, and $\auxvars$. The actual transformula.
          \item $\ctf$ is the closed formula of $\tf$ where every in-variable is replaced by the unprimed constant of the corresponding program variable and every out-variable is replaced by the primed constant of the corresponding program variable. For every aux-var there is a newly created constant.
          %\item $PreProc$ is the procedure in which the program is before executing the TF.
          %\item $SuccProc$ is the procedure the program is in after executing the TF.
        \end{itemize}
    \end{mydef}
    %

	\begin{mydef}
		A control flow graph (CFG) is a directed graph $G = (Loc, \Delta, \ell_{init}, \ell_E, st)$ of a program where
		\begin{itemize}
			\item  Loc is a set of program locations
			\item $\Delta$ is a set of internal program transitions consisting of tuples $(\ell, \ell')$ with $\ell, \ell' \in Loc$
			\item $\ell_{init} \in Loc$ is the initial location
			\item $\ell_E \subseteq Loc$ a set of error locations
			\item st: $\Delta \rightarrow \psi$ is a labeling function that assigns each transition in $\Delta$ a transformula $\psi$.
		\end{itemize}
	\end{mydef} \noindent
	 %
	 \bigskip

	To illustrate these definitions we will present two examples.
	
	\medskip

	\subsection*{Example 1:}
	Assume we are given program $P_0$ that is represented by CFG $G_0$ \\ $G_0 = (\{ \ell_0, \ell_1 \}, \{ (\ell_0, \ell_1)\}, \ell_0, \emptyset, ((\ell_0, \ell_1) 
	\mapsto \psi_0))$
	
	\bigskip
		
		\begin{minipage}{.3\textwidth}
			\centering
			\begin{align*}
				&\texttt{1: x, y : int}; \\
				&\texttt{2: x := 0}; \\
				&\texttt{3: y := 0;}
			\end{align*}
			
			\captionof{figure}{Program $P_0$}
			\label{fig:square}
		\end{minipage}%
		\hfill
		\begin{minipage}{.6\textwidth}
			\centering
		\begin{tikzpicture}[%
				->,
				>=stealth', shorten >=1pt, auto,
				node distance=3cm, scale=1, 
				transform shape, align=center,    
				smallnode/.style={inner sep=1.4}
				]
				\node[state](1){$\ell_0$};
				
				\node[state] (2) [below of=1] {$\ell_1$};
				
				\path (1) edge node {%
					$
					\psi_0 := \left\{
					\begin{array}{lcl}
					\invars       & = & \emptyset \\
					\outvars      & = & \{ x \mapsto x_{0}' , y \mapsto y_{0}' \} \\
					\auxvars      & = & \emptyset \\
					\varphi       & = & x_{0}' = 0 \; \land \; y_{0}' = 0 \\
					\widehat{\varphi} & = & c_{x}' = 0 \;\land\; c_{y}' = 0 \\
					\end{array}
					\right.
					$ %
				} (2)
				;

				);
				\end{tikzpicture}
							\captionof{figure}{$G_0$}
			\label{fig:rect}
		\end{minipage}%
	\bigskip

	Where $\psi_0 = (\invars_0, \outvars_0, \auxvars_0, \varphi_0, \widehat{\varphi}_0)$ is a transformula consisting of: 
	\begin{itemize}
		\item $\invars_0 = \emptyset$. There are no in-variables because $\varphi_0$ does not depend on any variables. It only assigns the out-vars to 0.
		\item $\outvars_0 = \{ x \mapsto x_0', y \mapsto y_0'\}$
		\item $\auxvars_0 = \emptyset$
		\item $\varphi_0: (x_0' = 0 \land y_0' = 0)$
		\item $\widehat{\varphi_0}: (c_x' = 0 \land c_y' = 0)$ with $c_x'$ and $c_y'$ being the primed constants of $x$ and $y$.
	\end{itemize}
	
	
	\subsection*{Example 2:}
	Assume we are given program $P_1$ that is represented by CFG $G_1$ \\ $G_1 = (\{ \ell_1, \ell_2 \}, \{ (\ell_1, \ell_2)\}, \ell_1, \emptyset, ((\ell_1, \ell_2) 
	\mapsto \psi_1))$ \\ \\

		\begin{minipage}{.3\textwidth}
			\centering
			\begin{align*}
				&\texttt{1: x, y : int}; \\
				&\texttt{2: x := x + 1}; \\
				&\texttt{3: y := y + 1;}
			\end{align*}

			
			\captionof{figure}{Program $P_1$}
			\label{fig:square}
		\end{minipage}%
		\hfill
		\begin{minipage}{.6\textwidth}
			\centering
		\begin{tikzpicture}[%
					->,
					>=stealth', shorten >=1pt, auto,
					node distance=3cm, scale=1, 
					transform shape, align=center,    
					smallnode/.style={inner sep=1.4}
					]
					\node[state](1){$\ell_1$};
					
					\node[state] (2) [below of=1] {$\ell_2$};
					
					\path (1) edge node {%
						$
						\psi_1 := \left\{
						\begin{array}{lcl}
						\invars       & = & \{x \mapsto x_{1}, y \mapsto y_{1} \} \\
						\outvars      & = & \{ x \mapsto x_{2}' , y \mapsto y_{2}' \} \\
						\auxvars      & = & \emptyset \\
						\varphi       & = & x_{2}' = x_{1} + 1 \; \land \; y_{2}' = x_{2}' + y_{1} \\
						\widehat{\varphi} & = & c_{x}' = c_x + 1 \;\land\; c_{y}' = c_{x}' + c_y \\
						\end{array}
						\right.
						$ %
					} (2)
					;
					
					
					);
					\end{tikzpicture}
			\captionof{figure}{$G_1$}
			\label{fig:rect}
		\end{minipage}%
	
\bigskip

	Where $\psi_1 = (\invars_1, \outvars_1, \auxvars_1, \varphi_1, \widehat{\varphi}_1)$ is a transformula consisting of: 
	\begin{itemize}
		\item $\invars_1 = \{x \mapsto x_1, y \mapsto y_1 \}$.
		\item $\outvars_1 = \{ x \mapsto x_2', y \mapsto y_2' \}$
		\item $\auxvars_1 = \emptyset $
		\item $	\varphi = ( x_{2}' = x_{1} + 1 \; \land \; y_{2}' = x_{2}' + y_{1} ) $
		\item $\widehat{\varphi} = ( c_{x}' = c_x + 1 \;\land\; c_{y}' = c_{x}' + c_y ) $ with $c_x, c_x'$ and $c_y, c_y'$ being the unprimed and primed constants of $x$ and $y$.
	\end{itemize}
    
	
	\subsection*{Example 3:}
	If we take both previous example and combine them to one CFG, we get \\ $G_{0+1} = (\{ \ell_0, \ell_1, \ell_2\}, \{ (\ell_0, \ell_1), (\ell_1, \ell_2)\}, \ell_0, \emptyset, ((\ell_0, \ell_1) \mapsto \psi_0, (\ell_1, \ell_2) \mapsto \psi_1))$.
	
	\bigskip

	\begin{minipage}{.3\textwidth}
		\centering
		\begin{align*}
			&\texttt{1: x, y : int}; \\
			&\texttt{2: x := 0}; \\
			&\texttt{3: y := 0;} \\
			&\texttt{4: x := x + 1}; \\
			&\texttt{5: y := y + 1;}
		\end{align*}

		
		
		\captionof{figure}{Program $P_{0+1}$}
		\label{fig:square}
	\end{minipage}%
	\hfill
	\begin{minipage}{.6\textwidth}
		\centering
		\begin{tikzpicture}[%
					->,
					>=stealth', shorten >=1pt, auto,
					node distance=3cm, scale=1, 
					transform shape, align=center,    
					smallnode/.style={inner sep=1.4}
					]
					\node[state](1){$\ell_0$};
					
					\node[state] (2) [below of=1] {$\ell_1$};
					
					\node[state] (3) [below of=2] {$\ell_2$};
					
					
					\path (1) edge node {%
						$
						\psi_0 := \left\{
						\begin{array}{lcl}
						\invars       & = & \emptyset \\
						\outvars      & = & \{ x \mapsto x_{0}' , y \mapsto y_{0}' \} \\
						\auxvars      & = & \emptyset \\
						\varphi       & = & x_{0}' = 0 \; \land \; y_{0}' = 0 \\
						\widehat{\varphi} & = & c_{x}' = 0 \;\land\; c_{y}' = 0 \\
						\end{array}
						\right.
						$ %
					} (2)
					;
					\path (2) edge node {%
						$
						\psi_1 := \left\{
						\begin{array}{lcl}
						\invars       & = & \{x \mapsto x_{1}, y \mapsto y_{1} \} \\
						\outvars      & = & \{ x \mapsto x_{2}', y \mapsto y_{2}' \} \\
						\auxvars      & = & \emptyset \\
						\varphi       & = & x_{2}' = x_{1} + 1 \; \land \; y_{2}' = x_{2}' + y_{1} \\
						\widehat{\varphi} & = & c_{x}' = c_x + 1 \;\land\; c_{y}' = c_{x}' + c_y \\
						\end{array}
						\right.
						$ %
					} (3)
					;
					\end{tikzpicture}
		\captionof{figure}{$G_{0+1}$}
		\label{fig:rect}
	\end{minipage}%
	\\ \\
	We see $CFG_{0+1}$ contains two TFs. We can get a single formula describing the whole program by concatenating those two formulas:
	$\psi_2 = \psi_0 \circ \psi_1$ \\
	
	\begin{mydef}
		A concatenation of two Transformulas 
		\begin{equation*}
		\psi_{1 \circ 2} = \psi_1 \circ \psi_2 = (\invars_{1 \circ 2}, \outvars_{1 \circ 2}, \auxvars_{1 \circ 2}, \varphi_{1 \circ 2}, \widehat{\varphi}_{1 \circ 2})
		\end{equation*}  yields one Transformula describing the behaviour of both of them. With
		\begin{itemize}
			\item $\invars_{1 \circ 2} = \invars_1$
			\item For $\outvars_{1 \circ 2}$ we have to distinguish three cases cases: 
			\begin{itemize}
				
				\item[I:] $(x \mapsto x_i') \in Out_1$ and $x  \not\in entries(Out_2)$, meaning program variable is solely modified in $\psi_1$. In that case the out-variable of the concatenation is the same as the out-variable of $\psi_1: $ $\outvars_{1 \circ 2} \cup (x \mapsto x_i')$ 
				\item[II:] $(x \mapsto x_j') \in Out_2$ and $x  \not\in entries(Out_1)$, meaning program variable is solely modified in $\psi_2$. In that case the out variable of the concatenation is the same as the out-variable of $\psi_2: $ $\outvars_{1 \circ 2} \cup (x \mapsto x_j')$ 
				\item[III:] $x \in entries(Out_1)$ and $x \in entries(Out_2)$, meaning program variable $x$ is modified in both transformulas which can create a term variable naming conflict. 
				In this case $\outvars_{1 \circ 2} \cup (x \mapsto \widehat{x_j}')$ where $\widehat{x_j}'$ is a fresh term variable that has not been used before.
				
			\end{itemize}

			\item $\auxvars_{1 \circ 2} = \{ \widehat{v_i} \ |\ v_i \in \auxvars_1 \cup \auxvars_2 \cup range(\invars_2) \text{ where } \widehat{v_i} \text{ is a fresh variable of } v_i \}$
			\item $\varphi_{1 \circ 2}$ = $\varphi_1[x_i' / x_j, v_i / \widehat{v_i} ] \land \varphi_2[v_j / \widehat{v_j}, x_j' / \widehat{x_j}']$, where
			 \begin{itemize}
				\item $\varphi_1[x_i' / x_j, v_i / \widehat{v_i} ] $ is $\varphi_1$ where we substitute every program variable mapping $(x \mapsto x_i') \in \outvars_1$ with $(x \mapsto x_j) \in \invars_2$ and each $v_i \in \auxvars_1$ with a fresh variable $\widehat{v_i}$.
				\item  $\varphi_2[v_j / \widehat{v_j}, x_j / \widehat{x_j}]$ is $\varphi_2$ where we substitute each $v_j \in \auxvars_2$ with a fresh variable $\widehat{v_j}$ and each mapping $(x \mapsto x_j') \in \outvars_2$, that fulfills out-variable case $III$, with $(x \mapsto \widehat{x_j}')$.
			\end{itemize} 
			
			%is the conjunction of $\varphi_1$ in which we replace every $(x, x_i) \in \outvars_0$ with $(PV, TV_2) \in \invars_2$ and each $v_1 \in \auxvars_1$ with a fresh variable $v_1'$ %and $\varphi_2$ in which we too replace each $v_2 \ in \auxvars_2$ with a fresh variable $v_2'$ and we replace each $(PV, TV_2) \in \outvars_2$ with a fresh variable $TV_2'$.
			\item $\widehat{\varphi}_{1 \circ 2}$ is the closed formula of $\varphi_{1 \circ 2}$ where every in-variable is replaced by the unprimed constant of the corresponding program variable and every out-variable is replaced by the primed constant. For every every $v_i \in \auxvars_{1 \circ 2}$ we introduce a fresh constant.
		\end{itemize}
	\end{mydef}

	\smallskip
	Using this definition we get $\psi_2 = \psi_0 \circ \psi_1$ with
	\begin{itemize}
		\item $\invars_2 = \invars_0 = \emptyset$
		\item $\outvars_2 = \{ x \mapsto x_3', y \mapsto y_3' \}$ \\ where $x_3'$ and $y_3'$ are new term variables because $x$ and $y$ are changed in both $\psi_0$ and $\psi_1$.
		\item $\auxvars_2 = \{x_1, y_1 \} $
		\item $\varphi_2 = (x_1 = 0 \land y_1 = 0 \land x_3' = x_1 + 1 \land y_3' = x_3' + y_1)$
		\item $\widehat{\varphi_2} = (c_1 = 0 \land c_2 = 0 \land c_x' = c_1 + 1 \land c'_y = c_x' + c_2)$ \\ We generated new constants for each aux-var: \\
		$x_1 \mapsto c_1, y_1 \mapsto c_2$
	\end{itemize}
	With this concatenation we can reduce $CFG_{0+1}$ from three locations and two TFs to two locations and only one TF $\psi_2$: \\
	
	\begin{figure}[H]
		\centering
		\begin{tikzpicture}[%
		->,
		>=stealth', shorten >=1pt, auto,
		node distance=3cm, scale=1, 
		transform shape, align=center,    
		smallnode/.style={inner sep=1.4}
		]
		\node[state](1){$\ell_0$};
		
		\node[state] (2) [below of=1] {$\ell_2$};
		
		\path (1) edge node {%
			$
			\psi_2 := \left\{
			\begin{array}{lcl}
			\invars       & = & \emptyset \\
			\outvars      & = & \{ x \mapsto x_3', y \mapsto y_3' \} \\
			\auxvars      & = &  \{x_1, y_1 \} \\
			\varphi       & = & x_1 = 0 \land y_1 = 0 \land x_3' = x_1 + 1 \land y_3' = x_3' + y_1 \\
			\widehat{\varphi} & = & c_1 = 0 \land c_2 = 0 \land c_x' = c_1 + 1 \land c'_y = c_x' + c_2 \\
			\end{array}
			\right.
			$ %
		} (2)
		;
		
		
		);
		\end{tikzpicture}
		\caption{Reduced CFG $G_{0+1}$.}
	\end{figure}

	\subsection{Interprocedual Control Flow Graphs}
	
	We want to be able to handle programs that consist of procedures that call other procedures, so called interprocedual programs, for that we need to modify our definitions from the previous chapter.
	
	\begin{mydef}
		An interprocedual control flow graph (ICFG) is a tuple \\$IG = (Loc, \Delta, \ell_{init}, \ell_E, st, proc)$ where $Loc$, $\Delta$, $\ell_{init}$, $\ell_E$, and st have the same definition as in regular CFGs. $proc$ is a set of different procedures found in the program. 
		%where transitions $(\ell, \ell' \in \Delta)$ are not only internal transitions but also call and return transitions. An ICFG can contain more than one procedure and with that being %able to represent programs that have more than one procedure as well.
	\end{mydef}
	In addition to the transitions we have seen before, ICFGs feature two new kinds that lead the control flow from one procedure of the program to another.
	\begin{mydef} Assume we are given an ICFG $IG = (Loc, \Delta, \ell_{init}, \ell_E, st, proc)$, we find three distinct classes of program transitions in $\Delta$:
		\begin{itemize}
			\item Internal transitions: An internal transition $(\ell, \ell') \in \Delta$ is a program transition where both $\ell$ and $\ell'$ are part of the same procedure. $st(\ell, \ell')$ is a transformula describing the change in variables.
			
			\item Call transitions:  A call transition leads the control flow from one procedure to another. We define that each procedure $p \in proc$ has a unique entry location $\ell^{entry}_p$. A transition $(\ell, \ell') \in \Delta$ is called a call transition, if $\ell$ is a location in procedure $p$ and $\ell'$ is the entry location of another procedure $q \in proc$. \\ $st(\ell, \ell')$ consists of three transformulas that function as a connection between $p$ and $q$, \\ $\psi_{old}, \psi_{global}$ and $\psi_{local}$: 
			\begin{itemize}
				\item$\psi_{old}$: Assuming we have global variables $g_0, ..., g_n$ that are modified by the procedure $q$. $\psi_{old}$ is a conjunction of assignments of each $g_i$ to a fresh variable $old_{i}$. 
				\item $\psi_{global}$: Reverse transformula of $\psi_{old}$ assigning the old variables $old_i$ back to its global counterparts $g_i$.
				\item $\psi_{local}$: Assuming we have an assignment where a local variable $x$ of procedure $p$ is used and modified by $q$. For example $x := $\texttt{foo(x)}, where \texttt{foo} increases $x$ by 10. \\
				In that case $\psi_{local}$ maps $x$ to the input variable of $q$.
			\end{itemize} 
			
			\item Return transitions: A return transition leads the control flow from one called procedure back to the caller procedure. We define that each procedure $p \in proc$ has one unique exit location $\ell^{exit}_p$. A transition $(\ell, \ell') \in \Delta$ is called a return transition, if $\ell$ is the exit location $\ell_q^{exit}$ of procedure $q \in proc$ and $\ell'$ is a location of caller procedure $p$. There is a map that maps each return to its corresponding call. \\
			$st(\ell, \ell')$ consists of transformula $\psi_{ass}$:
			\begin{itemize}
				\item $\psi_{return}$: In case that a local variable $x$ of $p$ was used and modified by $q$, $\psi_{return}$ maps the output of $q$ back to $x$.
			\end{itemize}
		\end{itemize}
	\end{mydef}
	
	\subsection*{Example 4:}
	Assume we are given program $P_2$ that is represented by ICFG $IG_2 = (Loc_2, \Delta_2, \ell_{init}, \ell_E, st_2, proc_2)$
	\begin{itemize}
		\item  $Loc_2= \{ main_0, main_1,  main_2, inc_1, inc_2 \} $
		\item $\Delta_2 = \{ (main_0, main_1), ( main_1, inc_0), (inc_0, inc_1), (inc_1, main_2)\}$
		\item $\ell_{init} = main_0$ 
		\item $\ell_E = \emptyset$
		\item $st_2 = (main_0, main_1) \mapsto \psi_0, (main_1, inc_1) \mapsto \psi_{global}, (main_1, inc_1) \mapsto \psi_{old}, (inc_0, inc_1) \mapsto \psi_1,  (inc_1, main_2) \mapsto \psi_{return})$
		\item $proc_2 = \{ main(), inc()\}$
	\end{itemize} 
	\bigskip
	
	\begin{minipage}{.3\textwidth}
		\centering
		\begin{align*}
		&\texttt{1: x, y : int}; \\ \\
		&\texttt{procedure main():} \\
		&\texttt{\hspace*{1em}1:  x := 0}; \\
		&\texttt{\hspace*{1em}2:  y := 0;} \\
		&\texttt{\hspace*{1em}3: call inc();} \\ \\
		&\texttt{procedure inc():} \\
		&\texttt{\hspace*{1em}1: y:= y\ +\ 1;} \\
		\end{align*}
		
		\captionof{figure}{Program $P_2$}
		\label{fig:square}
	\end{minipage}%
	\hfill
	\begin{minipage}{.6\textwidth}
		\centering
		\begin{tikzpicture}[%
		->,
		>=stealth', shorten >=1pt, auto,
		node distance=3cm, scale=1, 
		transform shape, align=center,    
		smallnode/.style={inner sep=1.4}
		]
		\node[state](1){$main_0$};
		
		\node[state] (2) [below of=1] {$main_1$};
		
		\node[state] (3) [below=15em of 2] {$inc_0$};
		
		\node[state] (4) [below of=3] {$inc_1$};
		
		\node[state] (5) [below of=4] {$main_2$};
		
		\path (1) edge node {%
			$
			\begin{array}{lcl} \SetToWidest{\psi_0} & := & \left\{
			\begin{array}{lcl}
			\invars       & = & \emptyset \\
			\outvars      & = & \{ x \mapsto x_{0}' , y \mapsto y_{0}' \} \\
			\auxvars      & = & \emptyset \\
			\varphi       & = & x_{0}' = 0 \; \land \; y_{0}' = 0 \\
			\widehat{\varphi} & = & c_{x}' = 0 \;\land\; c_{y}' = 0 \\
			\end{array}
			\right.
			\end{array}
			$ %
		} (2)
		;
		\path (2)[densely dotted] edge node {%
			$
			\begin{array}{lcl} \SetToWidest{\psi_{global}} & := & \left\{
			\begin{array}{lcl}
			\invars       & = & \{y_{old} \mapsto y_{old_0} \} \\
			\outvars      & = & \{ y \mapsto y_1' \} \\
			\auxvars      & = & \emptyset \\
			\varphi       & = & y_1' = y_{old_0} \\
			\widehat{\varphi} & = & c_{y}' = c_{old_y} \\
			\end{array}
			\right.
			\end{array}
			$ %
		} ($(2)!0.5!(3)$) edge[densely dotted] node[right=0.42\textwidth, below] {%
			$
			\begin{array}{lcl} \SetToWidest{\psi_{old}} & := & \left\{
			\begin{array}{lcl}
			\invars       & = & \{y \mapsto y_{2} \} \\
			\outvars      & = & \{y_{old} \mapsto y_{old_1}' \} \\
			\auxvars      & = & \emptyset \\
			\varphi       & = & y_{old_1}' = y_{2} \\
			\widehat{\varphi} & = & c_{{old_y}}' = c_{y} \\
			\end{array}
			\right.
			\end{array}
			$ } (3)
	
		;
		\path (3) edge node {%
			$
			\begin{array}{lcl} \SetToWidest{\psi_{1}} & := & \left\{
			\begin{array}{lcl}
			\invars       & = & \{ y_{old} \mapsto y_{old_2} \} \\
			\outvars      & = & \{ y \mapsto y_{3}' \} \\
			\auxvars      & = & \emptyset \\
			\varphi       & = & \; y_{3}' = y_{old_2} + 1 \\
			\widehat{\varphi} & = & c_{y}' = c_{old_y} + 1 \\
			\end{array}
			\right.
			\end{array}
			$ %
		} (4)
		;
		\path (4)[densely dotted] edge node {%
			$
		\begin{array}{lcl} \SetToWidest{\psi_{1}} & := & \left\{
			\begin{array}{lcl}
			\invars       & = & \emptyset \\
			\outvars      & = & \emptyset \\
			\auxvars      & = & \emptyset \\
			\varphi       & = & true\\
			\widehat{\varphi} & = & true \\
			\end{array}
			\right.
			\end{array}
			$ %
		} (5)
		;
		);
		\end{tikzpicture}
		\captionof{figure}{$IG_2$}
		\label{fig:rect}
	\end{minipage}%
	
	\pagebreak
	$P_2$ consists of two procedures, \texttt{main()} and \texttt{inc()}, that change the global variables $x$ and $y$. Note that we omit $\psi_{local}$ in this case because no local variables are used.
	\jw{more details + example with local vars.}
	
	
	\pagebreak
	
	
	\subsection{Interpolation}
	Interpolants are used as a way of covering a more general state space. There are multiple ways of finding interpolants for given formulas.
	In the following we will introduce Craig interpolation. 
	\jw{citation needed}
	
	\begin{mydef}
		Let $(A, B)$ be a pair of formulas such that $A \land B$ is unsatisfiable. A Craig interpolant $I$ for $(A, B)$ is a formula fulfilling the following characteristics:
		\begin{itemize}
			\item $A \Rightarrow I$
			\item $I \land B$ is unsatisfiable
			\item $I$ consists only of variables found in $A \cap B$
		\end{itemize}
	\end{mydef}

	\pagebreak
	
	%-------------------------------------------------%
	\section{PDR in Ultimate}
	%-------------------------------------------------%
	In this section we swiftly introduce our PDR implementation used in Ultimate, describe how it works, and introduce the problems we solved in this project.
	
	\subsection{PDR for Software}
	PDR was first devised as a means of hardware verification, however in my 2018 Bachelor's Thesis we proposed a way of using it on software. This approach was based on the technique described by Lange et al \cite{DBLP:conf/fmcad/0001NN15}.
	Instead of unrolling the transition relation of a given program's CFG, like other verification techniques, PDR checks only local transitions in a backwards-search like manner. \\ \\
	Given a program $P$ and its CFG  $G = (Loc, \Delta, \ell_{init}, \ell_E, st)$. To check correctness of $P$ PDR uses an array of so called \textsl{frames} for each program location $\ell \in Loc$. 
	\begin{mydef}
		A frame $F_{i,\ell}$ is a predicate mapped to a program location $\ell$ and an iteration of PDR, called level, $i$.
		Every program location $\ell \in Loc$ is assigned its own array of frames. These are used to overapproximate reachable states from the corresponding location.
	\end{mydef}
	Furthermore to check reachability of error state $\ell_E$ PDR maintains a stack of so called \textsl{proof-obligations}.
	\begin{mydef}
		A proof-obligation is a triple po = $(p, \ell, i)$ with a predicate $p$, a program location $\ell$, and a called level, $i$
		As the name suggests proof-obligations have to be proven. This is done by checking if $p$ is reachable at the given program location on the level $i$. If it is possible to generate a proof-obligation on level $i = 0$ we can say that $\ell_E$ is reachable from the initial state making the program unsafe.
	\end{mydef}

	Before entering the first iteration PDR initializes the first frame for each program location as $\{ false \}$ except the initial location whose frame is $\{ true \}$. \\ \\
	
	Starting a new iteration PDR adds a new frame to the program locations. This new frame is initialized as $\{true\}$ for every location. After this PDR generates its first proof-obligations: For every transition $(\ell, \ell_E) \in \Delta$ add new proof-obligation $(p, \ell, 1)$, $p$ being the transformula $st(\ell, \ell_E)$, to the proof-obligation stack. With the now no longer empty stack PDR enters the main loop which is divided into two phases: the \textsl{blocking-phase}, and \textsl{propagation-phase}.
	
	\bigskip
	
	First the blocking-phase: \\ 
	Given a proof-obligation $po_1 = (p, \ell, i)$ from the stack, the goal is to prove that the predicate $p$ is not reachable in $\ell$ on level $i$. \\ To verify that PDR constructs the following conjunction:
	\begin{equation*}
		F_{i - 1, \ell_{pre}} \land st(\ell_{pre}, \ell) \land p'
	\end{equation*}
	For every location $\ell_{pre}$ where $(\ell_{pre}, \ell) \in \Delta$. With 
	\begin{itemize}
		\item $F_{i - 1, \ell_{pre}}$ being the frame of $\ell_{pre}$ at level $i - 1$.
		\item $st(\ell_{pre}, \ell)$ being the transformula assigned to transition $(\ell_{pre}, \ell)$
		\item $p'$ being the primed variant of $p$. Every termvariable in $p$ has been substituted by the corresponding primed out-variable of $st(\ell_{pre}, \ell)$
	\end{itemize}
	This conjunction is checked for satisfiability by an SMT-solver.
	\begin{itemize}
		\item If unsatisfiable: PDR blocks the proof-obligation by updating $F_{i, \ell} = F_{i, \ell} \land \neg p$. \\ In case there is a future proof-obligation $(p, ell_{succ}, i + 1)$ for a successor $\ell_{succ}$ of $\ell$ generated, then PDR knows already that $p$ is not reachable. The proof-obligation is discarded form the stack.
		\item If satisfiable: PDR cannot prove that the proof-obligation is unreachable yet. Generate a new proof-obligation $po_i = (pre(st(\ell_{pre}, \ell), p), \ell_{pre}, i-1) $ for each predecessor location $\ell_{pre}$ of $\ell$, with $pre(st(\ell_{pre}, \ell), p)$ being the precondition of transformula $st(\ell_{pre}, \ell)$ and $p$. Both the new proof-obligations and the old proof-obligation are added on top of the proof-obligation stack.
	\end{itemize}
	This continues until there is a proof-obligation with level 0, proving the program unsafe, or the stack becomes empty.
	\bigskip
	
	If the proof-obligation stack could be emptied PDR enters the propagation-phase where it iterates through the frames of the program locations to find a fixpoint. \\
	\begin{mydef}
		We call a level $i$ where $F_{i, \ell} = F_{i-1, \ell}$ for every location $\ell \in Loc$ a fixpoint for the frame array. If there is a fixpoint the program is safe.
	\end{mydef}
	If there is neither a proof-obligation on level 0 or a fixpoint PDR starts the next iteration on an incremented level.
	
	\jw{Say that the termvariables in the frames are being substituted by the in-variables of TF}
	
	\bigskip
	
	\subsection{Example:}
	To illustrate the functionality of our PDR library consider program $P_3$ with corresponding CFG $ G_3 = (Loc_3, \Delta_3, \ell_{init}, \ell_E, st) $ with \\ 
	\begin{itemize}
		\item $Loc_3 = \{\ell_0, \ell_1, \ell_E \}$
		\item $\Delta_3 = \{(\ell_0, \ell_1), (\ell_1, \ell_1), (\ell_1, \ell_E) \}$
		\item $\ell_{init} = \ell_0 $
		\item $\ell_E = \ell_E$
		\item $st = ( (\ell_0, \ell_1) \mapsto \psi_0, (\ell_1, \ell_1) \mapsto \psi_1, (\ell_1, \ell_E) \mapsto \psi_E)$
	\end{itemize}

	\begin{minipage}{.3\textwidth}
	\centering
	\begin{align*}
	&\texttt{1: x, y : int}; \\
	&\texttt{2: x := 0}; \\
	&\texttt{3: y := x}; \\
	&\texttt{4: while(*) \{} \\
	&\texttt{5:} \hspace*{2em} \texttt{x := x + 1}; \\
	&\texttt{6:} \hspace*{2em} \texttt{y := y + 1;} \\
	&\texttt{7: \}} \\
	& \texttt{8: assert x == y}
	\end{align*}
	
	
	
	\captionof{figure}{Program $P_{3}$}
	\label{fig:square}
\end{minipage}%
\hfill
\begin{minipage}{.6\textwidth}
		\centering
		\hspace*{-1em}
		\begin{tikzpicture}[%
		->,
		>=stealth', shorten >=1pt, auto,
		node distance=5cm, scale=1, 
		transform shape, align=center,    
		smallnode/.style={inner sep=1.4}
		]
		\node [state](1){$\ell_0$};
		
		\node[state] (2) [below of=1] {$\ell_1$};
		
		\node[state] (4) [below of=2] {$\ell_E$};
		
		
		
		\path (1) edge node {%
			$
			\psi_{0} := \left\{
			\begin{array}{lcl}
			\invars       & = & \emptyset \\
			\outvars      & = & \{x \mapsto x_0', y \mapsto y_0' \} \\
			\auxvars      & = & \emptyset \\
			\varphi       & = & x_0' = 0\ \land\ y_0' = x_0' \\
			\widehat{\varphi} & = & c_x' = 0 \ \land \ c_{y}' = c_{x}' \\
			\end{array}
			\right.
			$ %
		} (2)
		(2) edge [loop right] node { $
			\psi_{1} := \left\{
			\begin{array}{lcl}
			\invars       & = & \{ x \mapsto x_1, y \mapsto y_1 \} \\
			\outvars      & = & \{ x \mapsto x_2', y \mapsto y_2' \} \\
			\auxvars      & = & \emptyset \\
			\varphi       & = & x_2' = x_1 + 1\ \land\ y_2' = y_2 + 1 \\
			\widehat{\varphi} & = & c_x' = c_x + 1 \ \land \ c_{y}' = c_{y} + 1 \\
			\end{array}
			\right.
			$} (2)
		(2) edge node {$
			\psi_{E} := \left\{
			\begin{array}{lcl}
			\invars       & = & \{ x \mapsto x_3, y \mapsto y_3 \} \\
			\outvars      & = & \emptyset \\
			\auxvars      & = & \emptyset \\
			\varphi       & = & x_3 \neq y_3 \\
			\widehat{\varphi} & = & c_x \neq c_{y} \\
			\end{array}
			\right.
			$ } (4)
		;
		
		
		);
		\end{tikzpicture}
		\captionof{figure}{$G_3$}
	\label{ex1} 
\end{minipage}% \\
\vspace*{3em} \\
	Note that $\psi_0$ and $\psi_1$ represent the concatenation of transformulas relating to the assignments in line 2, 3 and 5, 6 respectively. \\
	To verify whether it is possible to violate the assertion in line 8 we use PDR to check the reachability of $\ell_E$. \\ \par
	
	\textsl{1. Step: Check for 0-Counter-Example and Initialization} \\
	Is the initial location also the error location?
	No, we continue with initializing level 0 by adding to each $\ell \in Loc \backslash \{\ell_0, \ell_E\}$ a new frame $F_{0, \ell} = false$, for $\ell_0$ generating $F_{0, \ell_0} = true$. \\ \\
	
	
	\setlength\tabcolsep{0.35em}
	\begin{center}
		\begin{tabu}{cc}
			\toprule
			& level \\
			\cmidrule(lr){2-2}
			location & 0 \\
			\cmidrule{1-2}
			$\ell_0$ & $true$ \\
			$\ell_1$ & $false$ \\
			\bottomrule
		\end{tabu}
	\end{center}
	
	\hspace*{5cm}
	
	
	\textsl{2. Step: First Iteration} \\
	We initialize new frames for level 1 as \texttt{true}: \\
	
	\begin{center}
		\begin{tabu}{ccc}
			\toprule
			& \multicolumn{2}{c}{level} \\ 
			\cmidrule(lr){2-3}
			location & 0 & 1 \\
			\cmidrule{1-3}
			$\ell_0$ & $true$ & $true$ \\
			$\ell_1$ & $false$ & $true$ \\
			\bottomrule
		\end{tabu}
	\end{center}
	
	\hspace*{5cm}
	
	
	We see there is only one transition leading to $\ell_E$, $(\ell_1, x \neq y, \ell_E)$. We get the initial proof-obligation $(x \neq y, \ell_1, 1)$. \\ \\ \par
	\textsl{3. Step: First Blocking Phase} \\
	To block the initial proof-obligation $(x \neq y, \ell_1, 1)$ we have to check the two predecessors of $\ell_1$:
	
	\begin{itemize}
		\item predecessor: $\ell_0$
		\begin{equation*}
		\underbrace{true}_{F_{0, \ell_0}} \; \land \; \underbrace{x_0' = 0\ \land\ y_0' = x_0'}_{st(\ell_0, \ell_1)\; = \; \psi_0} \land \; \underbrace{x_0' \neq y_0'}_{p'}
		\end{equation*}
		Which is unsatisfiable, we update our frames with $\neg p = \neg{(x \neq y)} \equiv (x = y)$ to $F_{0, \ell_1}$ and $F_{1, \ell_1}$: \\
		
		\begin{center}
			\begin{tabu}{ccc}
				\toprule
				& \multicolumn{2}{c}{level} \\
				\cmidrule(lr){2-3}
				location & 0 & 1 \\
				\cmidrule{1-3}
				$\ell_0$ & $true$ & $true$ \\
				$\ell_1$ & $false \land x = y$ & $true \land x = y$ \\
				\bottomrule
			\end{tabu}
		\end{center}
		
		\hspace*{5cm}
		
		\item predecessor: $\ell_1$
		\begin{equation*}
		\underbrace{false \; \land \; x_1 = y_1}_{F_{0, \ell_1}} \; \land \; \underbrace{x_2' = x_1 + 1 \land y_2' = y_1 + 1}_{st(\ell_1, \ell_1)\; = \; \psi_{1}} \land \; \underbrace{ x_2' \neq y_2'}_{p'}
		\end{equation*}
		Which is unsatisfiable as well, but because $x = y$ has already been added to $F_{0, \ell_1}$ and $F_{1, \ell_1}$. The initial proof-obligation has been blocked and can be removed from the obligation stack.
		
	\end{itemize}
	Because the stack is now empty, we continue with the first propagation-phase. \\ \\ \par
	
	\textsl{4. Step: First Propagation-Phase} \\
	Check if there exists a global fixpoint $i$ where
	\begin{equation*}
	F_{i-1, \ell} = F_{i, \ell}
	\end{equation*}
	for every location $\ell \in Loc \backslash \{l_E \}$. \\
	We see there is no such $i$, we continue with the next level. \\ \\ \par
	
	\textsl{5. Step: Next Iteration} \\
	We initialize new frames for level 2 as \texttt{true}: \\
	
	\begin{center}
		\begin{tabu}{cccc}
			\toprule
			& \multicolumn{3}{c}{level} \\
			\cmidrule(lr){2-4}
			location & 0 & 1 & 2\\
			\cmidrule{1-4}
			$\ell_0$ & $true$ & $true$ & $true$ \\
			$\ell_1$ & $false$ & $x = y$ & $true$\\
			\bottomrule
		\end{tabu}
	\end{center}
	
	\hspace*{5cm}
	
	Again we generate the initial proof-obligation which is the same as before but on level 2. We have to block the initial proof-obligation $(x \neq y, \ell_1, 2).$ \\ \\ \par
	
	
	\textsl{6. Step: Second Blocking Phase} \\
	To block proof-obligation $(x \neq y, \ell_1, 2)$ we check the predecessors of $\ell_1$:
	
	\begin{itemize}
		\item predecessor: $\ell_0$
		\begin{equation*}
		\underbrace{true}_{F_{1, \ell_0}}\; \land \; \underbrace{x_0' = 0\ \land\ y_0' = x_0'}_{st(\ell_0, \ell_1)\; = \; \psi_0} \; \land \;  \underbrace{x_0' \neq y_0'}_{p'}
		\end{equation*}
		Which is unsatisfiable, we update our frames with $\neg (x \neq y) \equiv x = y$ to $F_{0, \ell_1}$, $F_{1, \ell_1}$ and $F_{2, \ell_1}$:
		
		\begin{center}
			\begin{tabu}{cccc}
				\toprule
				& \multicolumn{3}{c}{level} \\
				\cmidrule(lr){2-4}
				location & 0 & 1 & 2\\
				\cmidrule{1-4}
				$\ell_0$ & $true$ & $true$ & $true$ \\
				$\ell_1$ & $false$ & $x = y$ & $true \land x = y$ \\
				\bottomrule
			\end{tabu}
		\end{center}
		
		\hspace*{5cm}
		
		\item predecessor: $\ell_1$
		\begin{equation*}
		\underbrace{x_1 = y_1}_{F_{1, \ell_1}} \; \land \; \underbrace{x_2' = x_1 + 1 \land y_2' = y_1 + 1'}_{st(\ell_1, \ell_1)\; = \; \psi_{1}} \; \land  \; x_2' \neq y_2
		'
		\end{equation*}
		Which is unsatisfiable as well, but because $x = y$ has already been added to $F_{0, \ell_1}$, $F_{1, \ell_1}$, and $F_{2, \ell_1}$ we move on.
	\end{itemize}
	
	As there are no proof-obligations left, we continue with the second propagation-phase \\ \\ \par
	
	\textsl{7. Step: Second Propagation-Phase} \\
	
	\begin{center}
		\begin{tabu}{cccc}
			\toprule
			& \multicolumn{3}{c}{level} \\
			\cmidrule(lr){2-4}
			location & 0 & 1 & 2\\
			\cmidrule{1-4}
			$\ell_0$ & $true$ & $true$ & $true$ \\
			$\ell_1$ & $false$ & $x = y$ & $x = y$ \\
			\bottomrule
			\multicolumn{1}{c}{} &  \multicolumn{1}{c}{} & \multicolumn{2}{c}{\upbracefill} \\[-1ex]
			\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{2}{c}{$\scriptstyle global\ fixpoint$}\\
		\end{tabu}
	\end{center}
	
	\hspace*{5cm}
	
	We see that level 1 equals level 2 on all locations. The global fixpoint position is $i = 2$, $\ell_E$ is therefore not reachable.
	
	\subsection{Programs with Multiple Procedures}
	Most programs usually feature more than one procedure. For Verifiying them a simple CFG is not precise enough. Indstead, we use ICFGs to describe them. If we wanted to use PDR on ICFGs several problems arise:
	\jw{Explain why normal PDR does not work on procedures.}
	
	\section{Interprocedual PDR}
	\jw{Rewrite this for changed global frames: Global frames are now only a map of locations to disjunction of predicates}
	For using our PDR algorithm on programs with multiple programs and their representation as ICFGs, we propose the following recursive extension to our algorithm.
	\subsection{Recursive PDR}
	Because of the backwards-search like manner of PDR, it always finds a return transition before a call to another procedure. Our idea was to check those two procedures individually, meaning when PDR finds a return transition, it takes the sub-graph of the ICFG, that contains the corresponding procedure, handles it as a CFG and starts a new instance of PDR on that. \\ \\
	Assume we have a proof-obligation $po = (p, \ell, i)$ for some predicate $p$ at location $\ell$ on level $i$, and assume further that an incoming transition into $\ell$ is a return transition from a procedure $q$. \\
	What happens in the extended algorithm is now, that PDR analyses the procedures individually from each other, in other words, when PDR generates a proof-obligation, where an incoming transition is a return, it starts a new second PDR instance of the whole corresponding procedure $q$. \\
	Interprocedual PDR need to verify whether $p$ is reachable by executing $q$ in the program. \\
	
	Now that we can have multiple PDR instances we need to distinguish the individual frames sets. \\ We characterize two different kinds:
	\begin{itemize}
		\item The global frames are used in an instance overarching manner, they save all the learned information about reachability, that were compiled by individual PDR executions before and up until this point. 
		\item The local frames are the sets that are used by the respective PDR instances, they are equivalent to the frame arrays in the intraprocedual PDR algorithm from before. However, they are initialized by utilizing the information of the global frames.
	\end{itemize}
	Now the question is, what does a second PDR instance check for. The error locations are found outside of the procedure meaning we cannot generate individual proof-obligations.
	The intuition is, when we find a return transition $ret$ of another procedure $q$, we have a proof-obligation $po = (p, \ell_{ex}, i)$ where $\ell_{ex}$ is the return transition's target. Obligation $po$ exists because we want to check if predicate $p$ is satisfiable by the previous states of $\ell_{ex}$, so we have to check if executing the procedure belonging to $ret$ influences the program in a way that that is the case. \\ The second PDR instance constructs the initial proof-obligation $po_{proc} = (p, \ell_{ret}, 1)$ for $q$ where $\ell_{ret}$ is the source of $ret$, the last program location in $q$. \\ \par
	When the second execution of PDR terminates there are two possibilities: 
	\begin{itemize}
		\item It returns \texttt{unsatisfiable}: It is proven that $q$ does not change the execution of the program in a way that $p$ is satisfiable at $\ell_{ex}$. With that the original proof-obligation $po$ has been blocked and the updating of the local frames begins. Additionally the local frames of the finished second instance are added to the global frames to save learned information for subsequent procedure checking.
		\item It returns \texttt{satisfiable}: It is not proven that executing the procedure cannot lead the program to satisfy $p$. 
	\end{itemize}
	If latter case applies, the sub-execution returns satisfiable, there was a proof-obligation $po_{last} = (p_1, \ell, 1)$ where the SMT-query:
	\begin{equation}
		F_{\ell_{pre}, 0} \; \land \; st(\ell_{pre}, \ell) \; \land \; p_1'
	\end{equation}
	was satisfiable. Just like in the original algorithm we need to gather more information to block that proof-obligation. For that start a third instance of PDR on the program's remainder. Its initial proof-obligation starts at the program location $\ell_{call}$ where the procedure has been called from, and its predicate is the precondition $p_{pre} = pre(p_1, st(\ell_{pre}, \ell))$
	The goal is to verify whether that precondition is reachable from the initial location of the program. \\ \par
	When this third instance of PDR terminates we again have two possibilities: 
	\begin{itemize}
		\item It returns \texttt{satisfiable}: The rest of the program can reach $p_{pre}$ and with that the error will be reached through the procedure, making the program unsafe.
		\item It returns \texttt{Unsatisfiable}: $p_{pre}$ cannot be reached. The global frames are updated and PDR executes the second PDR instance on the procedure again to make sure it is blocked this time. If so, the original proof-obligation, that found the return in the first place, has been blocked and the frames are updated like before. If not, then there has to be another proof-obligation that starts another PDR instance on the rest of the program again.
	\end{itemize}
	If the execution of the third PDR instance finds another procedure in the program's remainder the whole process starts again, making PDR truly recursive. \\ \\
	
	The biggest changes are made to the blocking and propagation phase. In interprocedual PDR there will be a second PDR instance for a discovered procedure and if that returns satisfiability even a third on the remainder of the program. These instances rely on information gathered by each other. For example, when the third PDR instance deems a procedure to be safe, the global frames need to represent that, so that the other PDR instances can use this information to block proof-obligations more efficiently. \\ \\
	The propagation-phase remains unchanged, meaning each distinct PDR instance enters it after a successful blocking-phase. \\
	If there are no PDR instances left and the program was proven correct, then the global frames represent fitting path-interpolants that can be used to show unreachability of the error location.
	
	
	\subsection{Example}
	To illustrate the changes made to our PDR implementation reconsider $P_2$ from before with an added assertion in line 4 of \texttt{main()}.\\
	\pagestyle{plain} \\
	
	
	\pagebreak
	\pagestyle{empty}
	\begin{minipage}{.3\textwidth}
		\centering
		\begin{align*}
		&\texttt{1: x, y : int}; \\ \\
		&\texttt{procedure main():} \\
		&\texttt{\hspace*{1em}1:  x := 0}; \\
		&\texttt{\hspace*{1em}2:  y := 0;} \\
		&\texttt{\hspace*{1em}3: call inc();} \\
		&\texttt{\hspace*{1em}4: assert y == x + 1} \\ \\
		&\texttt{procedure inc():} \\
		&\texttt{\hspace*{1em}1: y := y\ +\ 1;} \\
		\end{align*}
		
		\captionof{figure}{Modified Program $P_2$}
		\label{fig:square}
	\end{minipage}%
	\hfill
	\begin{minipage}{.6\textwidth}
		\centering
		\begin{tikzpicture}[%
		->,
		>=stealth', shorten >=1pt, auto,
		node distance=3cm, scale=1, 
		transform shape, align=center,    
		smallnode/.style={inner sep=1.4}
		]
		\node[state](1){$main_0$};
		
		\node[state] (2) [below of=1] {$main_1$};
		
		\node[state] (3) [below=15em of 2] {$inc_0$};
		
		\node[state] (4) [below of=3] {$inc_1$};
		
		\node[state] (5) [below of=4] {$main_2$};
		
		\node[state] (6) [below of=5] {$main_E$};
			\path (1) edge node {%
		$
		\begin{array}{lcl} \SetToWidest{\psi_0} & := & \left\{
		\begin{array}{lcl}
		\invars       & = & \emptyset \\
		\outvars      & = & \{ x \mapsto x_{0}' , y \mapsto y_{0}' \} \\
		\auxvars      & = & \emptyset \\
		\varphi       & = & x_{0}' = 0 \; \land \; y_{0}' = 0 \\
		\widehat{\varphi} & = & c_{x}' = 0 \;\land\; c_{y}' = 0 \\
		\end{array}
		\right.
		\end{array}
		$ %
	} (2)
	;
	\path (2)[densely dotted] edge node {%
		$
		\begin{array}{lcl} \SetToWidest{\psi_{global}} & := & \left\{
		\begin{array}{lcl}
		\invars       & = & \{y_{old} \mapsto y_{old_0} \} \\
		\outvars      & = & \{ y \mapsto y_1' \} \\
		\auxvars      & = & \emptyset \\
		\varphi       & = & y_1' = y_{old_0} \\
		\widehat{\varphi} & = & c_{y}' = c_{old_y} \\
		\end{array}
		\right.
		\end{array}
		$ %
	} ($(2)!0.5!(3)$) edge[densely dotted] node[right=0.42\textwidth, below] {%
		$
		\begin{array}{lcl} \SetToWidest{\psi_{old}} & := & \left\{
		\begin{array}{lcl}
		\invars       & = & \{y \mapsto y_{2} \} \\
		\outvars      & = & \{y_{old} \mapsto y_{old_1}' \} \\
		\auxvars      & = & \emptyset \\
		\varphi       & = & y_{old_1}' = y_{2} \\
		\widehat{\varphi} & = & c_{{old_y}}' = c_{y} \\
		\end{array}
		\right.
		\end{array}
		$ } (3)
	
	;
	\path (3) edge node {%
		$
		\begin{array}{lcl} \SetToWidest{\psi_{1}} & := & \left\{
		\begin{array}{lcl}
		\invars       & = & \{ y_{old} \mapsto y_{old_2} \} \\
		\outvars      & = & \{ y \mapsto y_{3}' \} \\
		\auxvars      & = & \emptyset \\
		\varphi       & = & \; y_{3}' = y_{old_2} + 1 \\
		\widehat{\varphi} & = & c_{y}' = c_{old_y} + 1 \\
		\end{array}
		\right.
		\end{array}
		$ %
	} (4)
	;
	\path (4)[densely dotted] edge node {%
		$
		\begin{array}{lcl} \SetToWidest{\psi_{1}} & := & \left\{
		\begin{array}{lcl}
		\invars       & = & \emptyset \\
		\outvars      & = & \emptyset \\
		\auxvars      & = & \emptyset \\
		\varphi       & = & true\\
		\widehat{\varphi} & = & true \\
		\end{array}
		\right.
		\end{array}
		$ %
	} (5)
	;
		\path (5)[] edge node {%
			$
			\begin{array}{lcl} \SetToWidest{\psi_{E}} & := & \left\{
			\begin{array}{lcl}
			\invars       & = & \{ x \mapsto x_1, y \mapsto y_4 \} \\
			\outvars      & = & \emptyset \\
			\auxvars      & = & \emptyset \\
			\varphi       & = & y_4 \neq x_1 + 1 \\
			\widehat{\varphi} & = & c_{y} \neq c_x + 1\\
			\end{array}
			\right.
			\end{array}
			$  %
		} (6)
		;
		);
		\end{tikzpicture}
		\captionof{figure}{\hspace*{1em} $IG_2$ with Error location}
		\label{fig:rect}
	\end{minipage}%



\pagebreak
\pagestyle{plain}

	Because $P_2$ consists of two procedures we have to use interprocedual PDR to check reachability of error location $main_E$. \\ \\
	
	\textsl{1. Step: Check for 0-Counter-Example and Initialization} \\
	Is $main_0 = main_E$? No, begin initialization of the global frames which is similar to the 1. step of the ordinary algorithm, except there are multiple initial locations, $main_0$ for procedure \texttt{main} and $inc_0$ for \texttt{inc}, that need the true predicate. \\ \\
	
	\setlength\tabcolsep{0.35em}
	\begin{center}
		\begin{tabu}{cc}
			Global Frames \\
			\toprule
			location &  \\
			\cmidrule{1-2}
			$main_0$ & $true$ \\
			$main_1$ & $false$ \\
			$main_2$ & $false$ \\
			$inc_0$ & $true$ \\
			$inc_1$ & $false$\\
			\bottomrule
		\end{tabu}
	\end{center}
	
	\vspace*{1em}
	\textsl{2. Step: Local Frame Initialization} \\
	
	Now we start the first PDR instance, for it we need to construct its local frame array. \\ \\
	\begin{minipage}{.5\textwidth}
		\setlength\tabcolsep{0.35em}
		\begin{center}
			\begin{tabu}{cc}
				Global Frames \\
				\toprule
				location & \\
				\cmidrule{1-2}
				$main_0$ & $true$ \\
				$main_1$ & $false$ \\
				$main_2$ & $false$ \\
				$inc_0$ & $true$ \\
				$inc_1$ & $false$\\
				\bottomrule
			\end{tabu}
		\end{center}
	\end{minipage}
	\hfill
	\begin{minipage}{.4\textwidth}
	\setlength\tabcolsep{0.35em}
		\begin{center}
			\begin{tabu}{cc}
				Local Frames & \texttt{main} \\
				\toprule
				& level \\
				\cmidrule(lr){2-2}
				location & 0 \\
				\cmidrule{1-2}
				$main_0$ & $true$ \\
				$main_1$ & $false$ \\
				$main_2$ & $false$ \\
				$inc_0$ & $true$ \\
				$inc_1$ & $false$\\
				\bottomrule
			\end{tabu}
		\end{center}	
	\end{minipage}
	
	\vspace*{1em}
	\textsl{3. Step: First Iteration} \\
	Initialize the first level of the local frames as true for all locations. \\
	\begin{minipage}{.5\textwidth}
	\setlength\tabcolsep{0.35em}
	\begin{center}
		\begin{tabu}{cc}
			Global Frames \\
			\toprule
			location & \\
			\cmidrule{1-2}
			$main_0$ & $true$ \\
			$main_1$ & $false$ \\
			$main_2$ & $false$ \\
			$inc_0$ & $true$ \\
			$inc_1$ & $false$\\
			\bottomrule
		\end{tabu}
	\end{center}
	\end{minipage}
	\hfill
	\begin{minipage}{.4\textwidth}
		\setlength\tabcolsep{0.35em}
		\begin{center}
			\begin{tabu}{ccc}
				Local Frames & \texttt{main}\\
				\toprule
				& \multicolumn{2}{c}{level} \\
				\cmidrule(lr){2-3}
				location & 0 & 1 \\
				\cmidrule{1-3}
				$main_0$ & $true$ & $true$ \\
				$main_1$ & $false$ & $true$\\
				$main_2$ & $false$ & $true$\\
				$inc_0$ & $true$ & $true$\\
				$inc_1$ & $false$ & $true$\\
				\bottomrule
			\end{tabu}
		\end{center}	
	\end{minipage}
	
	\vspace*{1em}

	There is only one transition leading to the error location, we get the initial proof-obligation \\ $(y \neq x + 1, main_2, 1)$  \\ \\
	
	\textsl{4. Step: First Blocking-Phase} \\
	To block the proof-obligation $(y \neq x + 1, main_2, 1)$ we need to check each predecessor of $main_2$. There is only one, $inc_1$, but $st(inc_1, main_2)$ is the return transition of procedure \texttt{inc}, which necessitates the creation of a new PDR instance. \\ \\
	First get the CFG of procedure \texttt{inc}: \\ \\
	
	\begin{center}
	\begin{tikzpicture}[%
	->,
	>=stealth', shorten >=1pt, auto,
	node distance=3cm, scale=1, 
	transform shape, align=center,    
	smallnode/.style={inner sep=1.4}
	]

	\node[state] (3) [below=15em of 2] {$inc_0$};
	
	\node[state] (4) [below of=3] {$inc_1$};

	
	
	\path (3) edge node {%
		$
		\psi_{1} := \left\{
		\begin{array}{lcl}
		\invars       & = & \{ y \mapsto y_{2} \} \\
		\outvars      & = & \{ y \mapsto y_{3}' \} \\
		\auxvars      & = & \emptyset \\
		\varphi       & = & \; y_{3}' = y_{2} + 1 \\
		\widehat{\varphi} & = & c_{y}' = c_{y} + 1 \\
		\end{array}
		\right.
		$ %
	} (4)
	;
	);
	\end{tikzpicture}
	\captionof{figure}{$CFG$ of \texttt{inc}}
	\end{center}
	The initial proof-obligation of this second instance is $(y \neq x + 1, inc_1, 1)$, so the same predicate as in the initial obligation but on $inc_1$. \\
	
	\textsl{5. Step: Second PDR Local Frame and First Level Initialization} \\
	For this second instance we do not need the local frames of \texttt{main} but a new array that integrates only locations found in \texttt{inc}. \\
	
		\begin{minipage}{.5\textwidth}
		\setlength\tabcolsep{0.35em}
		\begin{center}
			\begin{tabu}{cc}
				Global Frames \\
				\toprule
				location & \\
				\cmidrule{1-2}
				$main_0$ & $true$ \\
				$main_1$ & $false$ \\
				$main_2$ & $false$ \\
				$inc_0$ & $true$ \\
				$inc_1$ & $false$\\
				\bottomrule
			\end{tabu}
		\end{center}
	\end{minipage}
	\hfill
	\begin{minipage}{.4\textwidth}
		\setlength\tabcolsep{0.35em}
		\begin{center}
			\begin{tabu}{ccc}
				Local Frames & \texttt{inc} \\
				\toprule
				& \multicolumn{2}{c}{level} \\
				\cmidrule(lr){2-3}
				location & 0 & 1 \\
				\cmidrule{1-3}
				$inc_0$ & $true$ & $true$ \\
				$inc_1$ & $false$ & $true$ \\
				\bottomrule
			\end{tabu}
		\end{center}	
	\end{minipage}
	
	\vspace*{1em}
	
	
	\textsl{6. Step: Second PDR First Blocking Phase} \\
	To block proof-obligation $(y \neq x + 1, inc_1, 1)$ we check the predecessor $inc_0$ of $inc_1$: \\
		\begin{equation*}
		\underbrace{true}_{F_{0, inc_0}}\; \land \; \underbrace{y_3' = y_2 + 1}_{st(inc_0, inc_1)\; = \; \psi_1} \land \; \underbrace{y_3' \neq x + 1}_{p'}
		\end{equation*}
		\jw{In dem fall dass eine variable weder in In oder Out vorkommt ist sie Aux, oder einfach eine freie Variable? Hier x}
		This is satisfiable because we do not know anything about x in this context. \\
		We generate a proof-obligation on level 0, terminating the PDR instance returning that the proof-obligation is satisfiable. \\ \\
	
	\textsl{7. Step: Blocking of Procedure inc} \\
	We know now, that it is possible to reach the error through \texttt{inc}. To know what has to hold for that to happen, we compute the precondition $pre(y \neq x + 1, y = y + 1) = (y \neq x)$. We have to prove whether $y \neq x$ holds when entering \texttt{inc} or not. We get a new proof-obligation $(y \neq x, main_1, 1)$. A third PDR instance is needed. \\ \\
	
	\textsl{8. Step: PDR on Remainder of Program} \\
	Get the CFG of the remainder of the program: \\ \\
	\begin{center}	
	\begin{tikzpicture}[%
	->,
	>=stealth', shorten >=1pt, auto,
	node distance=3cm, scale=1, 
	transform shape, align=center,    
	smallnode/.style={inner sep=1.4}
	]
	\node[state](1){$main_0$};
	
	\node[state] (2) [below of=1] {$main_1$};
	
	\path (1) edge node {%
		$
		\psi_0 := \left\{
		\begin{array}{lcl}
		\invars       & = & \emptyset \\
		\outvars      & = & \{ x \mapsto x_{0}' , y \mapsto y_{0}' \} \\
		\auxvars      & = & \emptyset \\
		\varphi       & = & x_{0}' = 0 \; \land \; y_{0}' = 0 \\
		\widehat{\varphi} & = & c_{x}' = 0 \;\land\; c_{y}' = 0 \\
		\end{array}
		\right.
		$ %
	} (2)
	;
	);
	\end{tikzpicture}
	\captionof{figure}{$CFG$ of $P_2$ Remainder}
	\label{fig:rect}
	\end{center}
	
	
	\textsl{9. Step: Third PDR Local Frame and First Level initialization} \\
	We again need a local frame array for the remainder: \\ \\
		\begin{minipage}{.5\textwidth}
		\setlength\tabcolsep{0.35em}
		\begin{center}
			\begin{tabu}{cc}
				Global Frames \\
				\toprule
				location &  \\
				\cmidrule{1-2}
				$main_0$ & $true$ \\
				$main_1$ & $false$ \\
				$main_2$ & $false$ \\
				$inc_0$ & $true$ \\
				$inc_1$ & $false$\\
				\bottomrule
			\end{tabu}
		\end{center}
	\end{minipage}
	\hfill
	\begin{minipage}{.4\textwidth}
		\setlength\tabcolsep{0.35em}
		\begin{center}
			\begin{tabu}{ccc}
				Local Frames & \texttt{remainder}\\
				\toprule
				& \multicolumn{2}{c}{level} \\
				\cmidrule(lr){2-3}
				location & 0 & 1\\
				\cmidrule{1-3}
				$main_0$ & $true$ & $true$ \\
				$main_1$ & $false$ & $true$\\
				\bottomrule
			\end{tabu}
		\end{center}	
	\end{minipage}
	
	\vspace*{2em}
	
	\textsl{10. Step: Third PDR First Blocking Phase} \\
		To block proof-obligation $(y \neq x, main_1, 1)$ we check the predecessor $main_0$ of $main_1$: \\
	\begin{equation*}
	\underbrace{true}_{F_{0, main_0}}\; \land \; \underbrace{x_0' = 0 \; \land \; y_0' = 0}_{\psi_0} \land \; \underbrace{y_0' \neq x_0'}_{p'}
	\end{equation*}
	Which is unsatisfiable, update the local frames of $main_1$ with $\neg(y \neq y) \equiv (y = x)$: \\ \\ 
	\begin{minipage}{.5\textwidth}
		\setlength\tabcolsep{0.35em}
		\begin{center}
			\begin{tabu}{cc}
				Global Frames \\
				\toprule
				location & \\
				\cmidrule{1-2}
				$main_0$ & $true$ \\
				$main_1$ & $false$ \\
				$main_2$ & $false$ \\
				$inc_0$ & $true$ \\
				$inc_1$ & $false$\\
				\bottomrule
			\end{tabu}
		\end{center}
	\end{minipage}
	\hfill
	\begin{minipage}{.4\textwidth}
		\setlength\tabcolsep{0.35em}
		\begin{center}
			\begin{tabu}{ccc}
				Local Frames & \texttt{remainder}\\
				\toprule
				& \multicolumn{2}{c}{level} \\
				\cmidrule(lr){2-3}
				location & 0 & 1\\
				\cmidrule{1-3}
				$main_0$ & $true$ & $true$ \\
				$main_1$ & $false$ & $y = x$\\
				\bottomrule
			\end{tabu}
		\end{center}	
	\end{minipage}
	
	\vspace*{2em}
	
	There are no other proof-obligations left, start the first propagation-phase. \\ \\
	
	\textsl{11. Step: Third PDR First Propagation Phase} \\
	Is there a global fixpoint in the local frames of remainder? No, we start a new iteration. \\ \\
	
	\textsl{12. Step: Third PDR Next Iteration} \\
	Initialize level 2 local frames:
	
			\begin{minipage}{.4\textwidth}
		\setlength\tabcolsep{0.35em}
		\begin{center}
			\begin{tabu}{cc}
				Global Frames \\
				\toprule
				& level \\
				\cmidrule(lr){2-2}
				location & 0 \\
				\cmidrule{1-2}
				$main_0$ & $true$ \\
				$main_1$ & $false$ \\
				$main_2$ & $false$ \\
				$inc_0$ & $true$ \\
				$inc_1$ & $false$\\
				\bottomrule
			\end{tabu}
		\end{center}
	\end{minipage}
	\hfill
	\begin{minipage}{.5\textwidth}
		\setlength\tabcolsep{0.35em}
		\begin{center}
			\begin{tabu}{cccc}
				Local Frames & \multicolumn{2}{c}{\texttt{remainder}} \\
				\toprule
					& \multicolumn{3}{c}{level} \\
				\cmidrule(lr){2-4}
				location & 0 & 1 & 2 \\
				\cmidrule{1-4}
				$main_0$ & $true$ & $true$ & $true$ \\
				$main_1$ & $false$ & $y = x$ & $true$\\
				\bottomrule
			\end{tabu}
		\end{center}	
	\end{minipage}
	
	\vspace*{2em}
	New initial proof-obligation. $(y \neq x, main_1, 2)$. \\ \\
	
	\textsl{13. Step: Third PDR Second Blocking Phase} \\
	To block proof-obligation $(y \neq x, main_1, 2)$ we check the predecessor $main_0$ of $main_1$: \\
	\begin{equation*}
	\underbrace{true}_{F_{1, main_0}}\; \land \; \underbrace{x_0' = 0 \; \land \; y_0' = 0}_{\psi_0} \land \; \underbrace{y_0' \neq x_0'}_{p'}
	\end{equation*}
	Which is also unsatisfiable, we again update the frames of $main_1$: \\ \\
	\begin{minipage}{.4\textwidth}
		\setlength\tabcolsep{0.35em}
		\begin{center}
			\begin{tabu}{cc}
				Global Frames \\
				\toprule
				location &  \\
				\cmidrule{1-2}
				$main_0$ & $true$ \\
				$main_1$ & $false$ \\
				$main_2$ & $false$ \\
				$inc_0$ & $true$ \\
				$inc_1$ & $false$\\
				\bottomrule
			\end{tabu}
		\end{center}
	\end{minipage}
	\hfill
	\begin{minipage}{.5\textwidth}
		\setlength\tabcolsep{0.35em}
		\begin{center}
			\begin{tabu}{cccc}
				Local Frames & \multicolumn{2}{c}{\texttt{remainder}} \\
				\toprule
				& \multicolumn{3}{c}{level} \\
				\cmidrule(lr){2-4}
				location & 0 & 1 & 2 \\
				\cmidrule{1-4}
				$main_0$ & $true$ & $true$ & $true$ \\
				$main_1$ & $false$ & $y = x$ & $y = x$\\
				\bottomrule
			\end{tabu}
		\end{center}	
	\end{minipage} 

	\vspace*{2em}

	\textsl{14. Step: Third PDR Second Propagation Phase} \\
	There is a fixpoint in the local frames, we see levels 1 and 2 are the equal.
	This means that the precondition for the procedure to lead to the error is not reachable.
	We now update the global frames with the local frames of remainder and update the initial location of \texttt{inc} with $y = x$ because we know now that this holds before entering the procedure. \\ The global frames contain every location where local frames do not, any location that is not covered by local get new levels initialized as true. We get updated global frames: \\
	
	\begin{minipage}{.4\textwidth}
		\setlength\tabcolsep{0.35em}
		\begin{center}
			\begin{tabu}{cc}
				Global Frames \\
				\toprule
				location &  \\
				\cmidrule{1-2}
				$main_0$ & $true$  \\
				$main_1$ & $y = x$\\
				$main_2$ & $true$ \\
				$inc_0$ & $y = x$  \\
				$inc_1$ & $true$\\
				\bottomrule
			\end{tabu}
		\end{center}
	\end{minipage}
	\hfill
	\begin{minipage}{.5\textwidth}
		\setlength\tabcolsep{0.35em}
		\begin{center}
			\begin{tabu}{cccc}
				Local Frames & \multicolumn{2}{c}{\texttt{remainder}} \\
				\toprule
				& \multicolumn{3}{c}{level} \\
				\cmidrule(lr){2-4}
				location & 0 & 1 & 2 \\
				\cmidrule{1-4}
				$main_0$ & $true$ & $true$ & $true$ \\
				$main_1$ & $false$ & $y = x$ & $true$\\
				\bottomrule
			\end{tabu}
		\end{center}	
	\end{minipage}

	\vspace*{2em}
	
	However we still have to block the proof-obligation from the second PDR instance: \\ $(y \neq x + 1, inc_1, 1)$. \\ Restart the second instance. \\ \\
	
	\textsl{15. Step: Second PDR Initialization} \\
	We again start by initializing the local using the global frames: \\ \\
	\begin{minipage}{.4\textwidth}
	\setlength\tabcolsep{0.35em}
	\begin{center}
		\begin{tabu}{cc}
			Global Frames \\
			\toprule
			location &  \\
			\cmidrule{1-2}
			$main_0$ & $true$  \\
			$main_1$ & $y = x$\\
			$main_2$ & $true$ \\
			$inc_0$ & $y = x$  \\
			$inc_1$ & $true$\\
			\bottomrule
		\end{tabu}
	\end{center}
\end{minipage}
	\hfill
	\begin{minipage}{.5\textwidth}
		\setlength\tabcolsep{0.35em}
		\begin{center}
			\begin{tabu}{cc}
				Local Frames & \texttt{inc}\\
				\toprule
				& level \\
				\cmidrule(lr){2-2}
				location & 0  \\
				\cmidrule{1-2}
				$inc_0$ & $y = x$  \\
				$inc_1$ & $false$ \\
				\bottomrule
			\end{tabu}
		\end{center}	
	\end{minipage} 

\vspace*{2em}

\textsl{16. Step: Second PDR First Iteration} \\
Instead of initializing level 1 frames as true, we make use of what we learned before by using the global frames: \\

	\begin{minipage}{.4\textwidth}
	\setlength\tabcolsep{0.35em}
	\begin{center}
		\begin{tabu}{cc}
			Global Frames \\
			\toprule
			location &  \\
			\cmidrule{1-2}
			$main_0$ & $true$  \\
			$main_1$ & $y = x$\\
			$main_2$ & $true$ \\
			$inc_0$ & $y = x$  \\
			$inc_1$ & $true$\\
			\bottomrule
		\end{tabu}
	\end{center}
\end{minipage}
\hfill
\begin{minipage}{.5\textwidth}
	\setlength\tabcolsep{0.35em}
	\begin{center}
		\begin{tabu}{ccc}
			Local Frames & \texttt{inc}\\
			\toprule
			& \multicolumn{2}{c}{level} \\
			\cmidrule(lr){2-3}
			location & 0 & 1  \\
			\cmidrule{1-3}
			$inc_0$ & $y = x$ & $y = x$  \\
			$inc_1$ & $false$ & $true$ \\
			\bottomrule
		\end{tabu}
	\end{center}	
\end{minipage}

\vspace*{1em}

\textsl{17. Step: Second PDR First Blocking Phase} \\
To block proof-obligation $(y \neq x + 1, inc_1, 1)$ we check the predecessor $inc_0$ of $inc_1$: \\
\begin{equation*}
\underbrace{y_2 = x_0}_{F_{0, inc_0}}\; \land \; \underbrace{y_3' = y_2 + 1}_{st(inc_0, inc_1)\; = \; \psi_1} \land \; \underbrace{y_3' \neq x_0 + 1}_{p'}
\end{equation*}

Which is now unsatisfiable. We can update the frames of $inc_1$ with $\neg(y \neq x + 1) \equiv (y = x + 1)$: \\ \\


	\begin{minipage}{.4\textwidth}
	\setlength\tabcolsep{0.35em}
	\begin{center}
		\begin{tabu}{cc}
			Global Frames \\
			\toprule
			location &  \\
			\cmidrule{1-2}
			$main_0$ & $true$  \\
			$main_1$ & $y = x$\\
			$main_2$ & $true$ \\
			$inc_0$ & $y = x$  \\
			$inc_1$ & $true$\\
			\bottomrule
		\end{tabu}
	\end{center}
\end{minipage}
\hfill
\begin{minipage}{.5\textwidth}
	\setlength\tabcolsep{0.35em}
	\begin{center}
		\begin{tabu}{ccc}
			Local Frames & \texttt{inc}\\
			\toprule
			& \multicolumn{2}{c}{level} \\
			\cmidrule(lr){2-3}
			location & 0 & 1  \\
			\cmidrule{1-3}
			$inc_0$ & $y = x$ & $y = x$  \\
			$inc_1$ & $false$ & $y = x + 1$ \\
			\bottomrule
		\end{tabu}
	\end{center}	
\end{minipage}

\vspace*{2em}
\textsl{18. Step: Second PDR First Propagation Phase} \\
There is no fixpoint in the local frames yet, meaning we would start a new Iteration with the same proof-obligation but on an incremented level.\\
After the blocking of proof-obligation $(y \neq x + 1, inc_1, 2)$, which works analogously to step 17 just on level 2, we get frames: \\ \\ 

	\begin{minipage}{.4\textwidth}
	\setlength\tabcolsep{0.35em}
	\begin{center}
		\begin{tabu}{cc}
			Global Frames \\
			\toprule
			location &  \\
			\cmidrule{1-2}
			$main_0$ & $true$  \\
			$main_1$ & $y = x$\\
			$main_2$ & $true$ \\
			$inc_0$ & $y = x$  \\
			$inc_1$ & $true$\\
			\bottomrule
		\end{tabu}
	\end{center}
\end{minipage}
\hfill
\begin{minipage}{.5\textwidth}
	\setlength\tabcolsep{0.35em}
	\begin{center}
		\begin{tabu}{cccc}
			Local Frames & \multicolumn{1}{c}{\texttt{inc}} \\
			\toprule
			& \multicolumn{3}{c}{level} \\
			\cmidrule(lr){2-4}
			location & 0 & 1 & 2\\
			\cmidrule{1-4}
			$inc_0$ & $y = x$ & $y = x$ & $y = x$  \\
			$inc_1$ & $false$ & $y = x + 1$  & $y = x + 1$\\
			\bottomrule
		\end{tabu}
	\end{center}	
\end{minipage} \\ \\

Fixpoint at level 1 and 2, result is that the procedure now no longer leads to the initial proof-obligation anymore. Update global frames with the local frames of \texttt{inc}: \\ \\

	\begin{minipage}{.4\textwidth}
	\setlength\tabcolsep{0.35em}
	\begin{center}
		\begin{tabu}{cc}
			Global Frames \\
			\toprule
			location &  \\
			\cmidrule{1-2}
			$main_0$ & $true$  \\
			$main_1$ & $y = x$\\
			$main_2$ & $true$ \\
			$inc_0$ & $y = x$  \\
			$inc_1$ & $y = x + 1$\\
			\bottomrule
		\end{tabu}
	\end{center}
\end{minipage}
\hfill
\begin{minipage}{.45\textwidth}
	\setlength\tabcolsep{0.35em}
	\begin{center}
		\begin{tabu}{cccc}
			Local Frames & \texttt{inc}\\
			\toprule
			& \multicolumn{3}{c}{level} \\
			\cmidrule(lr){2-4}
			location & 0 & 1 & 2\\
			\cmidrule{1-4}
			$inc_0$ & $y = x$ & $y = x$ & $y = x$  \\
			$inc_1$ & $false$ & $y = x + 1$  & $y = x + 1$\\
			\bottomrule
		\end{tabu}
	\end{center}	
\end{minipage} \\ \\

With that we have blocked the very first PDR's initial proof-obligation $(y \neq x + 1, main_2, 1)$. Update $main_2$ global frames with $\neg(y \neq x + 1) \equiv (y = x + 1)$ : \\


	\setlength\tabcolsep{0.35em}
	\begin{center}
		\begin{tabu}{cc}
			Global Frames \\
			\toprule
			location &  \\
			\cmidrule{1-2}
			$main_0$ & $true$  \\
			$main_1$ & $y = x$\\
			$main_2$ & $y = x + 1$ \\
			$inc_0$ & $y = x$  \\
			$inc_1$ & $y = x + 1$\\
			\bottomrule
		\end{tabu}
	\end{center}


\vspace*{2em}

\textsl{19. Step: First PDR Blocking Phase} \\
After the preceding two PDR instances we finally have blocked the initial proof-obligation of the first instance. We update the local frames of \texttt{main}: \\

	\begin{minipage}{.4\textwidth}
	\setlength\tabcolsep{0.35em}
	\begin{center}
		\begin{tabu}{cc}
			Global Frames \\
			\toprule
			location &  \\
			\cmidrule{1-2}
			$main_0$ & $true$  \\
			$main_1$ & $y = x$\\
			$main_2$ & $y = x + 1$ \\
			$inc_0$ & $y = x$  \\
			$inc_1$ & $y = x + 1$\\
			\bottomrule
		\end{tabu}
	\end{center}
\end{minipage}
\hfill
\begin{minipage}{.4\textwidth}
	\setlength\tabcolsep{0.35em}
		\begin{center}
			\begin{tabu}{ccc}
				Local Frames & \texttt{main}\\
				\toprule
				& \multicolumn{2}{c}{level} \\
				\cmidrule(lr){2-3}
				location & 0 & 1 \\
				\cmidrule{1-3}
				$main_0$ & $true$ & $true$ \\
				$main_1$ & $false$ & $true$\\
				$main_2$ & $false$ & $y = x + 1$\\
				$inc_0$ & $true$ & $true$\\
				$inc_1$ & $false$ & $true$\\
				\bottomrule
			\end{tabu}
		\end{center}	
\end{minipage}

\vspace*{2em}

\textsl{20. Step First PDR First Propagation Phase} \\
Do we have a fixpoint in \texttt{main}'s local frames? No, start new Iteration of first PDR with same initial proof-obligation on an incremented level. \\ \\

\textsl{21. Step First PDR Next Iteration} \\
Because there is no fixpoint in the local frames we have to do steps 4 to 20 again, this time for the initial proof-obligation $(y \neq x + 1, main_2, 2)$ which results in the following frames: \\ \\

	\begin{minipage}{.4\textwidth}
	\setlength\tabcolsep{0.35em}
	\begin{center}
		\begin{tabu}{cc}
			Global Frames \\
			\toprule
			location &  \\
			\cmidrule{1-2}
			$main_0$ & $true$  \\
			$main_1$ & $y = x$\\
			$main_2$ & $y = x + 1$ \\
			$inc_0$ & $y = x$  \\
			$inc_1$ & $y = x + 1$\\
			\bottomrule
		\end{tabu}
	\end{center}
\end{minipage}
\hfill
\begin{minipage}{.45\textwidth}
	\setlength\tabcolsep{0.35em}
	\begin{center}
		\begin{tabu}{cccc}
			Local Frames & \texttt{main}\\
			\toprule
			& \multicolumn{3}{c}{level} \\
			\cmidrule(lr){2-4}
			location & 0 & 1 & 2\\
			\cmidrule{1-4}
			$main_0$ & $true$ & $true$ & $true$\\
			$main_1$ & $false$ & $true$ & $true$\\
			$main_2$ & $false$ & $y = x + 1$ & $y = x + 1$\\
			$inc_0$ & $true$ & $true$ & $true$\\
			$inc_1$ & $false$ & $true$ & $true$\\
			\bottomrule
		\end{tabu}
	\end{center}	
\end{minipage}

\vspace*{1em}

\textsl{22. Step First PDR Second Propagation Phase} \\
We see that the local frames of \texttt{main} have fixpoint level 1 and 2, which means that the error location is not reachable, making the first PDR instance safe.  \\ \\

\textsl{23. Global Propagation Phase} \\
We now check if there is a fixpoint in the global frames as well. Which is true as level 1 equals 2, with that we return that the whole program is safe.

	
	
	
	\pagebreak
	\section{Using Interpolants}
	Adding the negated proof-obligation to the frames works well in most cases. Consider program $\mathcal{A}$ in Figure 3.4. The initial proof-obligation on level $i$ is $(x = 1, \ell_1, i)$, because $\ell_1$ has two predecessors we have to check:
	\begin{equation}
	F_{\ell_1, i - 1} \land x' = x + 1 \land x' = 1
	\end{equation}
	\begin{equation}
	F_{\ell_0, i - 1} \land x' = 2 \land x' = 1
	\end{equation}
	for satisfiability. \\
	Formula (3.1) is satisfiable until we get a proof-obligation on level 1, because frame $F_{\ell_1, 0}$ is always false. \\
	Formula (3.2) is always unsatisfiable, in each level we add $x \neq 1$ to $\ell_1$'s frames. That formula however is not strong enough to block the chain of satisfiable obligations of (3.1) in the next level, which is inefficient.
	
	
	
	\section{Evaluation}
	Run the benchmarks again and compare them to the ones from last year, where we will see (hopefully) a speedup.
	
	\pagebreak
	
\addcontentsline{toc}{chapter}{Bibliography}
\bibliographystyle{plain}
\bibliography{bib}

	
\end{document}