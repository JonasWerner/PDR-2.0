\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage{xspace}
\usepackage{tabu}
\usepackage[%
  hyperindex,%
  plainpages=false,%
  pdfusetitle]{hyperref}
\usepackage[all]{hypcap}
\usepackage{cite}
\usepackage{booktabs}
\usepackage{url}
\usepackage{listings}
\usepackage{enumitem}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{tikz}
\usetikzlibrary{positioning,shapes.geometric, arrows,automata, decorations.pathreplacing}
\usepackage{pgf}
\usepackage{slantsc}
\usepackage{geometry}
\usepackage{amssymb}
\usepackage{subcaption}

\usepackage[%disable,%
  colorinlistoftodos,%
  color=cyan!50!white,%
  bordercolor=cyan!50!black]{todonotes}

%%%%%%%%%%%% Colors 
%% a somewhat friendly scheme for 5 different colors 
\definecolor{g1}		{RGB}{215,25,28} % a kind of red
\definecolor{g2}		{RGB}{253,174,97} % a kind of orange
\definecolor{g3}		{RGB}{255,255,191} % a kind of yellow
\definecolor{g4}		{RGB}{171,217,233} % a kind of light blue 
\definecolor{g5}		{RGB}{44,123,182} % a kind of dark blue 

\definecolor{gr1}		{RGB}{250, 250, 250}
\definecolor{gr2}		{RGB}{229, 229, 229} % some grey

% color of interpolants
\definecolor{grey}{RGB}{200,200,200}

%color for pictures
\colorlet{outlineblue}		{g5}
\colorlet{fillblue}			{g4}
\colorlet{darkback}			{gr2}
\colorlet{lightback}		{gr1}
\colorlet{stmtcolor}		{gr2} %default statement color
\colorlet{subgraphcolor}	{g3} %default statement color


%%%%%%%%%%%% Setup
\newtheorem{name}{Printed output}
\newtheorem{mydef}{Definition}

\hypersetup{
colorlinks=true,        % false: boxed links; true: colored links
linkcolor=g1,        % color of internal links
citecolor=g1,        % color of links to bibliography
filecolor=g1,        % color of file links
urlcolor=g1          % color of external links
}


\lstdefinestyle{boogie}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  xleftmargin=\parindent,
  showstringspaces=false,
  basicstyle=\footnotesize\ttfamily,
  numbers=left,
  xleftmargin=.6cm
}

\lstset{escapechar=@,style=boogie}

%%%%%%%%%%%% Comments
\newif\iffinal
%\finaltrue % comment out to remove comments 
 
\iffinal
\newcommand\mycom[1]{}
\else
\newcommand\mycom[1]{#1}
\overfullrule=1mm
\fi
\setlength\parindent{0pt}

\newcommand{\jw}[1]{\mycom{\todo[color=blue!40,inline]{\small JW: #1}}}
\newcommand{\jwl}[1]{\mycom{\todo[color=blue!40,inline,caption={Beschreibung},nolist]{\small #1}}}
\newcommand{\dd}[1]{\mycom{\todo[color=orange!40,inline]{\small DD: #1}}}
\newcommand{\ddl}[1]{\mycom{\todo[color=orange!40,inline,caption={Beschreibung},nolist]{\small #1}}}

\newcommand{\all}[1]{\mycom{\todo[color=green!40,inline]{\small #1}}}
\newcommand{\meta}[1]{\mycom{\todo[color=blue!10,inline,caption={Beschreibung},nolist]{\setlist{nolistsep}\small #1}}}
\newcommand{\xxx}{\mycom{\stfootcol{Placeholder}{blue!20}\xspace}}
\newcommand{\cn}{\mycom{\stfootcol{Cite}{blue!20}\xspace}}


%%%%%%%%%%%% Actual content
\begin{document}
	\newcommand{\HorizontalLine}{\rule{\linewidth}{0.3mm}}
	
	\title{ \HorizontalLine \\ \textbf{Interprocedual and Interpolating \\ Property Directed Reachability in \textsc{Ultimate}} \HorizontalLine}
	

	
	\author{Jonas Werner \\ Dr. Daniel Dietsch}


	
	\date{} 
	
	\maketitle
	
	\begin{abstract}
	In a previous project we implemented a library using PDR for software verification in the program analysis framework ULTIMATE. However \jw{...}
	\end{abstract}
	
	
	%-------------------------------------------------%
	\section{Introduction}
	%-------------------------------------------------%
	
	Property Directed Reachability (PDR) was first devised as a hardware verification paradigm by Aaron Bradley \cite{DBLP:conf/vmcai/Bradley11}. It however showed potential as a software verification method as well.
	In the course of my 2018 Bachelor's Thesis we devised a method of using Property Directed Reachability on software in the software analysis framework \textsc{Ultimate} \cite{Zitat02}. \\
	Our approach was based on the technique described by Lange et al \cite{DBLP:conf/date/WelpK13}. \\ The implementation worked however solely on intraprocedual programs, meaning that if we encountered a call to another procedure, it would no longer continue the verification process. \\
	Furthermore our implementation did not make use of interpolants which broaden the state space covered by blocked proof-obligations. \\
	This project aims at expanding PDR with both interprocedual analysis capabilities and usage of interpolants. \jw{\textbf{Both kinds of interpolants: Craig and selfless (citation needed)}} \par
    This paper is structured as follows, firstly we will give some background definition of interprocedual program analysis, and interpolants, then we will describe our changes made to our PDR library.
	
	%-------------------------------------------------%
	\section{Background}
	%-------------------------------------------------%
	In this section we will give preliminary definitions on what interprocedual programs are and what interpolants we use.
	
    
    \newcommand{\tf}{\ensuremath{\varphi}\xspace}
    \newcommand{\ctf}{\ensuremath{\hat{\varphi}}\xspace}
    \newcommand{\invars}{\ensuremath{In}\xspace}
    \newcommand{\outvars}{\ensuremath{Out}\xspace}
    \newcommand{\auxvars}{\ensuremath{Aux}\xspace}
	
	\subsection{Interprocedual Control Flow Graphs}	
	Given a program we need a way to model its control flow to check whether given error states can be reachable or not, for that we introduce control flow graphs.
	
	\begin{mydef}
	Each program variable $(PV)$, is mapped to a tuple $(proc, tv, c, c')$ that consists of: 
		\begin{itemize}
			\item A label $proc$ that assigns the name of the corresponding procedure in which the program variable occurs. \\
			If the program variable is a global variable, $proc = null$
			\item A termvariable (TV) that is used in term operations and SMT calls.
			\item A constant $c$
			\item A primed constant $c'$
		\end{itemize}
	\end{mydef}
	For example, assume we have the local variable $x$ that is used in procedure $foo$. $x$ is mapped to the tuple $(foo, v_x, c_x, c'_x)$.
	%\begin{itemize}
	%	\item $proc(x) = foo$
	%	\item $tv(x) = t_x$
	%	\item constant of x: $c_x$
	%	\item primed constant of x: $c'_x$
	%\end{itemize} 
	
	\begin{mydef}
		A predicate $P = (V, \psi, \hat{\psi})$ is a tuple consisting of: 
		\begin{itemize}
			\item A set of program variables $V$
			\item A formula $\psi$ over the termvariables of the program variables in $var$
			\item A formula $\hat{\psi}$ which is the closed formula of $\psi$ where every termvariable is replaced by the corresponding program variable unprimed constant.
		\end{itemize}
	\end{mydef}
	

    \begin{mydef}
        A transformula (TF) is a tuple \\ $TF = (\invars, \outvars, \auxvars, \tf, \ctf)$ with 
        \begin{itemize}
          \item $\invars : PV \rightarrow TV$ is a mapping from program variables to unprimed termvariables called the in-variables
          \item $\outvars : PV \rightarrow TV$ is a mapping from program variables to primed termvariables called the out-variables
          \item $\auxvars \subseteq TV$ is a set of termvariables that only exist in the context of this transformula called the aux-variables,
          \item $\tf$ is a formula over termvariables from $\invars$, $\outvars$, and $\auxvars$
          \item $\ctf$ is the closed formula of $\tf$ where every in-variable is replaced by the unprimed constant of the corresponding program variable and every out-variable is replaced by the primed constant of the corresponding program variable.
          %\item $PreProc$ is the procedure in which the program is before executing the TF.
          %\item $SuccProc$ is the procedure the program is in after executing the TF.
        \end{itemize}
    \end{mydef}
    %

	\begin{mydef}
		A control flow graph (CFG) is a directed graph G = ($Loc$, $\Delta$, $\ell_{init}$, $\ell_E$, st) of a program where
		\begin{itemize}
			\item  Loc is a set of program locations
			\item $\Delta$ is a set of internal program transitions consisting of tuples $(\ell, \ell')$, $\ell, \ell' \in Loc$
			\item $\ell_{init} \in Loc$ is the initial location
			\item $\ell_E \subseteq Loc$ a set of error locations
			\item st: $\Delta \rightarrow TF$ is a labeling function that assigns each transition in $\Delta$ a transformula.
		\end{itemize}
	\end{mydef} \noindent
	 %
	 \bigskip

	To illustrate these definitions, assume we are given the program represented by the CFG \\ $G = (\{ \ell_0, \ell_1 \}, \{ (\ell_0, \ell_1)\}, \ell_0, \emptyset, ((\ell_0, \ell_1) 
	\mapsto TF_0))$
	\begin{figure}[h]
		\centering
		\begin{tikzpicture}[%
		->,
		>=stealth', shorten >=1pt, auto,
		node distance=2cm, scale=1, 
		transform shape, align=center,    
		smallnode/.style={inner sep=1.4}
		]
		\node[state](1){$\ell_0$};
		
		\node[state] (2) [below of=1] {$\ell_1$};
		
		
		
		
		
		\path (1) edge node {$TF_0$} (2)
		;
		
		
		);
		\end{tikzpicture}
		\caption{CFG G.}
	\end{figure}
	

	\bigskip\bigskip\bigskip\noindent
	Because we want to deal with programs that consist of more than one procedure, we first need to define three classes of program transitions.
	
	\begin{mydef} In interprocedual programs we find three distinct classes of program transitions:
		\begin{itemize}
			\item Internal transitions: An internal transition $(\ell, \ell') \in \Delta$ is a program transition where both $\ell$ and $\ell'$ are part of the same procedure. 
			
			\item Call transitions:  A call transition leads the control flow from one procedure to another. We define that each procedure p in a program has a unique entry location $\ell^{entry}_p$. A transition $(\ell, \ell') \in \Delta$ is called a call transition, if $\ell$ is a location in procedure $p$ and $\ell'$ is the entry location of another procedure $q$.
			
			\item Return transitions: A return transition leads the control flow from one called procedure back to the original caller procedure. We define that each procedure $p$ has one unique exit location $\ell^{exit}_p$. A transition $(\ell, \ell') \in \Delta$ is called a return transition, if $\ell$ is the exit location $\ell_q^{exit}$ of procedure $q$ and $\ell'$ is a location of caller procedure $p$. Each return has a corresponding call.
		\end{itemize}
	\end{mydef}
\jw{explain the formulas}
	 \bigskip\noindent
	Considering these program transitions we need to modify our definition of a CFG to get Interprocedual Control Flow Graphs. As CFGs only deal with internal transitions.
	\begin{mydef}
		An interprocedual control flow graph (ICFG) is a CFG G = ($Loc$, $\Delta$, $\ell_{init}$, $\ell_E$, st) where transitions $(\ell, \ell' \in \Delta)$ are not only internal transitions but also call and return transitions. An ICFG can contain more than one procedure and with that being able to represent programs that have more than one procedure as well.
	\end{mydef}
	
	\jw{\textbf{@ToDo extend example by procedure call}} 
	We see that foo calls bar during its run. Our current definition of CFGs do not support those calls yet, we need to expand it to deal with programs containing multiple procedures.
	
	
	\pagebreak
		
	\subsection{Interpolation}
	Interpolants are used as a way of covering a more general state space. There are multiple ways of finding interpolants for given formulas.
	In the following we will introduce two techniques: Craig interpolation and Selfless interpolation. 
	\jw{citation needed}
	
	\begin{mydef}
		Let $(A, B)$ be a pair of formulas such that $A \land B$ is unsatisfiable. A Craig interpolant $I$ for $(A, B)$ is a formula fulfilling the following characteristics:
		\begin{itemize}
			\item $A \Rightarrow I$
			\item $I \land B$ is unsatisfiable
			\item $I$ consists only of variables found in $A \cap B$
		\end{itemize}
	\end{mydef}

	Next to Craig interpolation, there are other kinds of getting interpolants:
	\begin{mydef}
		\jw{Introduce Selfless interpolation}
	\end{mydef}
	\pagebreak
	
	%-------------------------------------------------%
	\section{PDR in Ultimate}
	%-------------------------------------------------%
	In this section we swiftly introduce our PDR implementation, describe how it works, and introduce the problems we solved in this project.
	
	\subsection{PDR for Software}
	PDR was first devised as a means of hardware verification, however in my 2018 Bachelor's Thesis we divised a way of using it on software, this approach was based on the technique described by Lange et al. \jw{Citation needed}
	Instead of unrolling the transition relation of a given program's CFG like other verification techniques PDR checks only local transitions in a backwards-search like manner.
	\smallskip
	To check correctness of a program PDR uses an array of frames for each program location $\ell \in Loc$. 
	\begin{mydef}
		A frame $F_{i,\ell}$ is a predicate mapped to a program location $\ell$ and an iteration of PDR, called level, $i$.
		Every program location $\ell \in Loc$ is assigned its own array of frames. These are used to overapproximate reachable states from the corresponding location.
	\end{mydef}
	Furthermore to check reachability of an error state PDR maintains a stack of so called proof-obligations.
	\begin{mydef}
		A proof-obligation is a triple po = $(t, \ell, i)$ with a predicate $t$, a program location $\ell$, and an integer, called level, $i$
		As the name suggests proof-obligations have to be proven, if it is possible to generate a proof-obligation on level $i = 0$ we can say that the program is unsafe.
	\end{mydef}
	PDR is initialized by generating the first frame for each program location as $\{ false \}$ except the initial location which has frame $\{ true \}$. If there is a transition $(\ell, \ell_E)$ into an error node PDR generates its first proof-obligation $(t, \ell, 1)$ $t$ being the transformula $st(\ell, \ell_E)$.
	In each new iteration PDR adds a new frame to the program locations. This new frame is $\{true\}$, further
	an iteration of PDR is divided into two phases, the blocking-phase, and the propagation-phase.
	
	\bigskip
	
	In the blocking phase we try to clear the proof-obligation stack by generating queries to an SMT-solver.
	If the query is unsatisfiable, we can block the proof-obligation, meaning that the successors of the given transformula are not reachable.
	If such a query is satisfiable we know that the corresponding proof-obligation cannot be proven unreachable yet. Given proof-obligation  $po = (t, \ell, i)$ we generate a new proof-obligation $(st(\ell_{pre}, \ell), \ell_{pre}, i-1) $ for each predecessor location $\ell_{pre}$ of $\ell$.
	
	\bigskip
	
	If the proof-obligation stack could be emptied, PDR enters the propagation-phase where it scouts through the frames of the program locations to find a fixpoint. \\
	\begin{mydef}
		A fixpoint in the frames is a level $i$ where $F_{i, \ell} = F_{i-1, \ell}$ for every location $\ell \in Loc$. If there is such a fixpoint then the given program is safe.
	\end{mydef}
	If there is neither a proof-obligation on level 0 or a fixpoint in the frames, PDR starts a new iteration.

	\subsection{SMT-queries}
	As mentioned before, PDR constructs queries to an SMT-solver in the blocking-phase, those are conjunctions of three predicates. Given proof-obligation $po = (t, \ell, i)$ the algorithm checks for each predecessor location of $\ell$ $\ell_{pre}$ if the formula:
	\begin{equation*}
	F_{i - 1, \ell_{pre}} \land T_{\ell_{pre} \rightarrow \ell} \land t'
	\end{equation*}
	is satisfiable. Here $F_{i-1, \ell_{pre}}$ is the frame of a previous iteration, $T_{\ell_{pre} \rightarrow \ell}$ is the transformula $st(\ell_{pre}, \ell)$ and $t'$ is the primed proof-obligation.
	Our implementation treats the frame as a precondition, the proof-obligation as a post condition and the transformula as a possible transition between. Now to check the satisfiability we use the closed formula of the precondition
	

	\jw{todo}
	\section{Using Interpolants}
	Adding the negated proof-obligation to the frames works well in most cases. Consider program $\mathcal{A}$ in Figure 3.4. The initial proof-obligation on level $i$ is $(x = 1, \ell_1, i)$, because $\ell_1$ has two predecessors we have to check:
	\begin{equation}
	F_{\ell_1, i - 1} \land x' = x + 1 \land x' = 1
	\end{equation}
	\begin{equation}
	F_{\ell_0, i - 1} \land x' = 2 \land x' = 1
	\end{equation}
	for satisfiability. \\
	Formula (3.1) is satisfiable until we get a proof-obligation on level 1, because frame $F_{\ell_1, 0}$ is always false. \\
	Formula (3.2) is always unsatisfiable, in each level we add $x \neq 1$ to $\ell_1$'s frames. That formula however is not strong enough to block the chain of satisfiable obligations of (3.1) in the next level, which is inefficient.
	
	\section{Evaluation}
	Run the benchmarks again and compare them to the ones from last year, where we will see (hopefully) a speedup.
	
	\pagebreak
	
\addcontentsline{toc}{chapter}{Bibliography}
\bibliographystyle{plain}
\bibliography{bib}

	
\end{document}