\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage{xspace}
\usepackage{tabu}
\usepackage[%
  hyperindex,%
  plainpages=false,%
  pdfusetitle]{hyperref}
\usepackage[all]{hypcap}
\usepackage{cite}
\usepackage{booktabs}
\usepackage{url}
\usepackage{listings}
\usepackage{enumitem}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{tikz}
\usetikzlibrary{positioning,shapes.geometric, arrows,automata, decorations.pathreplacing, calc}
\usepackage{pgf}
\usepackage{slantsc}
\usepackage{geometry}
\usepackage{amssymb}
\usepackage{subcaption}
\usepackage{float}


\usepackage[%disable,%
  colorinlistoftodos,%
  color=cyan!50!white,%
  bordercolor=cyan!50!black]{todonotes}

%%%%%%%%%%%% Colors 
%% a somewhat friendly scheme for 5 different colors 
\definecolor{g1}		{RGB}{215,25,28} % a kind of red
\definecolor{g2}		{RGB}{253,174,97} % a kind of orange
\definecolor{g3}		{RGB}{255,255,191} % a kind of yellow
\definecolor{g4}		{RGB}{171,217,233} % a kind of light blue 
\definecolor{g5}		{RGB}{44,123,182} % a kind of dark blue 

\definecolor{gr1}		{RGB}{250, 250, 250}
\definecolor{gr2}		{RGB}{229, 229, 229} % some grey

% color of interpolants
\definecolor{grey}{RGB}{200,200,200}

%color for pictures
\colorlet{outlineblue}		{g5}
\colorlet{fillblue}			{g4}
\colorlet{darkback}			{gr2}
\colorlet{lightback}		{gr1}
\colorlet{stmtcolor}		{gr2} %default statement color
\colorlet{subgraphcolor}	{g3} %default statement color


%%%%%%%%%%%% Setup
\newtheorem{name}{Printed output}
\newtheorem{mydef}{Definition}

\hypersetup{
colorlinks=true,        % false: boxed links; true: colored links
linkcolor=g1,        % color of internal links
citecolor=g1,        % color of links to bibliography
filecolor=g1,        % color of file links
urlcolor=g1          % color of external links
}


\lstdefinestyle{boogie}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  xleftmargin=\parindent,
  showstringspaces=false,
  basicstyle=\footnotesize\ttfamily,
  numbers=left,
  xleftmargin=.6cm
}

\lstset{escapechar=@,style=boogie}

%%%%%%%%%%%% Comments
\newif\iffinal
%\finaltrue % comment out to remove comments 
 
\iffinal
\newcommand\mycom[1]{}
\else
\newcommand\mycom[1]{#1}
\overfullrule=1mm
\fi
\setlength\parindent{0pt}

\newcommand{\jw}[1]{\mycom{\todo[color=blue!40,inline]{\small JW: #1}}}
\newcommand{\jwl}[1]{\mycom{\todo[color=blue!40,inline,caption={Beschreibung},nolist]{\small #1}}}
\newcommand{\dd}[1]{\mycom{\todo[color=orange!40,inline]{\small DD: #1}}}
\newcommand{\ddl}[1]{\mycom{\todo[color=orange!40,inline,caption={Beschreibung},nolist]{\small #1}}}

\newcommand{\all}[1]{\mycom{\todo[color=green!40,inline]{\small #1}}}
\newcommand{\meta}[1]{\mycom{\todo[color=blue!10,inline,caption={Beschreibung},nolist]{\setlist{nolistsep}\small #1}}}
\newcommand{\xxx}{\mycom{\stfootcol{Placeholder}{blue!20}\xspace}}
\newcommand{\cn}{\mycom{\stfootcol{Cite}{blue!20}\xspace}}


%%%%%%%%%%%% Actual content
\begin{document}
	\newcommand{\HorizontalLine}{\rule{\linewidth}{0.3mm}}
	
	\title{ \HorizontalLine \\ \textbf{Interprocedual and Interpolating \\ Property Directed Reachability in \textsc{Ultimate}} \HorizontalLine}
	

	
	\author{Jonas Werner \\ Dr. Daniel Dietsch}


	
	\date{} 
	
	\maketitle
	
	\begin{abstract}
	In a previous project we implemented a library using PDR for software verification in the program analysis framework ULTIMATE. However \jw{...}
	\end{abstract}
	
	
	%-------------------------------------------------%
	\section{Introduction}
	%-------------------------------------------------%
	
	Property Directed Reachability (PDR) was first devised as a hardware verification paradigm by Aaron Bradley \cite{DBLP:conf/vmcai/Bradley11}. It however showed potential as a software verification method as well.
	In the course of my 2018 Bachelor's Thesis we devised a method of using Property Directed Reachability on software in the software analysis framework \textsc{Ultimate} \cite{Zitat02}. \\
	Our approach was based on the technique described by Lange et al \cite{DBLP:conf/date/WelpK13}. \\ The implementation however worked solely on intraprocedual programs, meaning programs containing more than one procedure could not be analysed. \\
	Furthermore our implementation did not make use of interpolants which broaden the state space covered by blocked proof-obligations. \\
	This project aims at expanding PDR with both interprocedual analysis capabilities and usage of interpolants. \par
	
    This paper is structured as follows, firstly we will give some background definition of interprocedual program analysis and interpolants, then we will introduce the functionality of our PDR library in Ultimate. In chapter 4 we propose a way of using PDR on programs containing multiple procedures. Chapter 6 discusses our usage of interpolants. Lastly Chapter 7 will provide some benchmarks showing the effectiveness of interprocedual PDR.
    
    \pagebreak
	
	%-------------------------------------------------%
	\section{Background}
	%-------------------------------------------------%
	In this section we will give preliminary definitions on what interprocedual programs are and what interpolants we use.
	
    
    \newcommand{\tf}{\ensuremath{\varphi}\xspace}
    \newcommand{\ctf}{\ensuremath{\widehat{\varphi}}\xspace}
    \newcommand{\invars}{\ensuremath{In}\xspace}
    \newcommand{\outvars}{\ensuremath{Out}\xspace}
    \newcommand{\auxvars}{\ensuremath{Aux}\xspace}
	
	\subsection{Control Flow Graphs}	
	Given a program we need a way to model its control flow to check whether given error states can be reachable or not, for that we introduce control flow graphs.
	
	\begin{mydef}
	Each program variable $(PV)$ $x$, is mapped to a tuple $(proc, tv, c, c')$ that consists of: 
		\begin{itemize}
			\item A label $proc$ that assigns the name of the corresponding procedure in which the program variable occurs. 
			%If the program variable is a global variable, $proc = null$
			\item A termvariable (TV) $x_i$ that is used in term operations and SMT calls.
			\item A constant $c_x$
			\item A primed constant $c_x'$
		\end{itemize}
	\end{mydef}
	For example, assume we have the local variable $x$ that is used in procedure $foo$. $x$ is mapped to the tuple $(foo, x_0, c_x, c'_x)$. 
	%\begin{itemize}
	%	\item $proc(x) = foo$
	%	\item $tv(x) = t_x$
	%	\item constant of x: $c_x$
	%	\item primed constant of x: $c'_x$
	%\end{itemize} 
	
	\begin{mydef}
		A predicate $P = (V, \phi, \widehat{\phi})$ is a tuple consisting of: 
		\begin{itemize}
			\item A set of program variables $V$
			\item A formula $\phi$ over the termvariables of the program variables in $V$
			\item A formula $\widehat{\phi}$ which is the closed formula of $\phi$ where every termvariable is replaced by the corresponding program variable unprimed constant.
		\end{itemize}
	\end{mydef}
	

    \begin{mydef}
        A transformula (TF) is a tuple $\psi = (\invars, \outvars, \auxvars, \tf, \ctf)$ with 
        \begin{itemize}
          \item $\invars : x \rightarrow x_i$ is a mapping from program variables to unprimed termvariables called the in-variables
          \item $\outvars : x \rightarrow x_i'$ is a mapping from program variables to primed termvariables called the out-variables
          \item $\auxvars: \{ v_i \}$ is a set of termvariables $v_i$ that only exist in the context of this transformula called the aux-variables,
          \item $\tf$ is a formula over termvariables from $\invars$, $\outvars$, and $\auxvars$. The actual transformula.
          \item $\ctf$ is the closed formula of $\tf$ where every in-variable is replaced by the unprimed constant of the corresponding program variable and every out-variable is replaced by the primed constant of the corresponding program variable. For every aux-var there is a newly created constant.
          %\item $PreProc$ is the procedure in which the program is before executing the TF.
          %\item $SuccProc$ is the procedure the program is in after executing the TF.
        \end{itemize}
    \end{mydef}
    %

	\begin{mydef}
		A control flow graph (CFG) is a directed graph $G = (Loc, \Delta, \ell_{init}, \ell_E, st)$ of a program where
		\begin{itemize}
			\item  Loc is a set of program locations
			\item $\Delta$ is a set of internal program transitions consisting of tuples $(\ell, \ell')$ with $\ell, \ell' \in Loc$
			\item $\ell_{init} \in Loc$ is the initial location
			\item $\ell_E \subseteq Loc$ a set of error locations
			\item st: $\Delta \rightarrow \psi$ is a labeling function that assigns each transition in $\Delta$ a transformula $\psi$.
		\end{itemize}
	\end{mydef} \noindent
	 %
	 \bigskip

	To illustrate these definitions we will present two examples.
	
	\medskip

	\subsection*{Example 1:}
	Assume we are given program $P_0$ that is represented by CFG $G_0$ \\ $G_0 = (\{ \ell_0, \ell_1 \}, \{ (\ell_0, \ell_1)\}, \ell_0, \emptyset, ((\ell_0, \ell_1) 
	\mapsto \psi_0))$
	
	\bigskip
		
		\begin{minipage}{.3\textwidth}
			\centering
			\begin{align*}
				&\texttt{1: x, y : int}; \\
				&\texttt{2: x := 0}; \\
				&\texttt{3: y := 0;}
			\end{align*}
			
			\captionof{figure}{Program $P_0$}
			\label{fig:square}
		\end{minipage}%
		\hfill
		\begin{minipage}{.6\textwidth}
			\centering
		\begin{tikzpicture}[%
				->,
				>=stealth', shorten >=1pt, auto,
				node distance=3cm, scale=1, 
				transform shape, align=center,    
				smallnode/.style={inner sep=1.4}
				]
				\node[state](1){$\ell_0$};
				
				\node[state] (2) [below of=1] {$\ell_1$};
				
				\path (1) edge node {%
					$
					\psi_0 := \left\{
					\begin{array}{lcl}
					\invars       & = & \emptyset \\
					\outvars      & = & \{ x \mapsto x_{0}' , y \mapsto y_{0}' \} \\
					\auxvars      & = & \emptyset \\
					\varphi       & = & x_{0}' = 0 \; \land \; y_{0}' = 0 \\
					\widehat{\varphi} & = & c_{x}' = 0 \;\land\; c_{y}' = 0 \\
					\end{array}
					\right.
					$ %
				} (2)
				;

				);
				\end{tikzpicture}
							\captionof{figure}{$G_0$}
			\label{fig:rect}
		\end{minipage}%
	\bigskip

	Where $\psi_0 = (\invars_0, \outvars_0, \auxvars_0, \varphi_0, \widehat{\varphi}_0)$ is a transformula consisting of: 
	\begin{itemize}
		\item $\invars_0 = \emptyset$. There are no in-variables because $\varphi_0$ does not depend on any variables. It only assigns the out-vars to 0.
		\item $\outvars_0 = \{ x \mapsto x_0', y \mapsto y_0'\}$
		\item $\auxvars_0 = \emptyset$
		\item $\varphi_0: (x_0' = 0 \land y_0' = 0)$
		\item $\widehat{\varphi_0}: (c_x' = 0 \land c_y' = 0)$ with $c_x'$ and $c_y'$ being the primed constants of $x$ and $y$.
	\end{itemize}
	
	
	\subsection*{Example 2:}
	Assume we are given program $P_1$ that is represented by CFG $G_1$ \\ $G_1 = (\{ \ell_1, \ell_2 \}, \{ (\ell_1, \ell_2)\}, \ell_1, \emptyset, ((\ell_1, \ell_2) 
	\mapsto \psi_1))$

		\begin{minipage}{.3\textwidth}
			\centering
			\begin{align*}
				&\texttt{1: x, y : int}; \\
				&\texttt{2: x := x + 1}; \\
				&\texttt{3: y := y + 1;}
			\end{align*}

			
			\captionof{figure}{Program $P_1$}
			\label{fig:square}
		\end{minipage}%
		\hfill
		\begin{minipage}{.6\textwidth}
			\centering
		\begin{tikzpicture}[%
					->,
					>=stealth', shorten >=1pt, auto,
					node distance=3cm, scale=1, 
					transform shape, align=center,    
					smallnode/.style={inner sep=1.4}
					]
					\node[state](1){$\ell_1$};
					
					\node[state] (2) [below of=1] {$\ell_2$};
					
					\path (1) edge node {%
						$
						\psi_1 := \left\{
						\begin{array}{lcl}
						\invars       & = & \{x \mapsto x_{1}, y \mapsto y_{1} \} \\
						\outvars      & = & \{ x \mapsto x_{2}' , y \mapsto y_{2}' \} \\
						\auxvars      & = & \emptyset \\
						\varphi       & = & x_{2}' = x_{1} + 1 \; \land \; y_{2}' = x_{2}' + y_{1} \\
						\widehat{\varphi} & = & c_{x}' = c_x + 1 \;\land\; c_{y}' = c_{x}' + c_y \\
						\end{array}
						\right.
						$ %
					} (2)
					;
					
					
					);
					\end{tikzpicture}
			\captionof{figure}{$G_1$}
			\label{fig:rect}
		\end{minipage}%
\bigskip

	Where $\psi_1 = (\invars_1, \outvars_1, \auxvars_1, \varphi_1, \widehat{\varphi}_1)$ is a transformula consisting of: 
	\begin{itemize}
		\item $\invars_1 = \{x \mapsto x_1, y \mapsto y_1 \}$.
		\item $\outvars_1 = \{ x \mapsto x_2', y \mapsto y_2' \}$
		\item $\auxvars_1 = \emptyset $
		\item $	\varphi = ( x_{2}' = x_{1} + 1 \; \land \; y_{2}' = x_{2}' + y_{1} ) $
		\item $\widehat{\varphi} = ( c_{x}' = c_x + 1 \;\land\; c_{y}' = c_{x}' + c_y ) $ with $c_x, c_x'$ and $c_y, c_y'$ being the unprimed and primed constants of $x$ and $y$.
	\end{itemize}
    
	
	\subsection*{Example 3:}
	If we take both previous example and combine them to one CFG, we get \\ $G_{0+1} = (\{ \ell_0, \ell_1, \ell_2\}, \{ (\ell_0, \ell_1), (\ell_1, \ell_2)\}, \ell_0, \emptyset, ((\ell_0, \ell_1) \mapsto \psi_0, (\ell_1, \ell_2) \mapsto \psi_1))$.
	
	\bigskip

	\begin{minipage}{.3\textwidth}
		\centering
		\begin{align*}
			&\texttt{1: x, y : int}; \\
			&\texttt{2: x := 0}; \\
			&\texttt{3: y := 0;} \\
			&\texttt{4: x := x + 1}; \\
			&\texttt{5: y := y + 1;}
		\end{align*}

		
		
		\captionof{figure}{Program $P_{0+1}$}
		\label{fig:square}
	\end{minipage}%
	\hfill
	\begin{minipage}{.6\textwidth}
		\centering
		\begin{tikzpicture}[%
					->,
					>=stealth', shorten >=1pt, auto,
					node distance=3cm, scale=1, 
					transform shape, align=center,    
					smallnode/.style={inner sep=1.4}
					]
					\node[state](1){$\ell_0$};
					
					\node[state] (2) [below of=1] {$\ell_1$};
					
					\node[state] (3) [below of=2] {$\ell_2$};
					
					
					\path (1) edge node {%
						$
						\psi_0 := \left\{
						\begin{array}{lcl}
						\invars       & = & \emptyset \\
						\outvars      & = & \{ x \mapsto x_{0}' , y \mapsto y_{0}' \} \\
						\auxvars      & = & \emptyset \\
						\varphi       & = & x_{0}' = 0 \; \land \; y_{0}' = 0 \\
						\widehat{\varphi} & = & c_{x}' = 0 \;\land\; c_{y}' = 0 \\
						\end{array}
						\right.
						$ %
					} (2)
					;
					\path (2) edge node {%
						$
						\psi_1 := \left\{
						\begin{array}{lcl}
						\invars       & = & \{x \mapsto x_{1}, y \mapsto y_{1} \} \\
						\outvars      & = & \{ x \mapsto x_{2}', y \mapsto y_{2}' \} \\
						\auxvars      & = & \emptyset \\
						\varphi       & = & x_{2}' = x_{1} + 1 \; \land \; y_{2}' = x_{2}' + y_{1} \\
						\widehat{\varphi} & = & c_{x}' = c_x + 1 \;\land\; c_{y}' = c_{x}' + c_y \\
						\end{array}
						\right.
						$ %
					} (3)
					;
					\end{tikzpicture}
		\captionof{figure}{$G_{0+1}$}
		\label{fig:rect}
	\end{minipage}%
	\\ \\
	We see $CFG_{0+1}$ contains two TFs. We can get a single formula describing the whole program by concatenating those two formulas:
	$\psi_2 = \psi_0 \circ \psi_1$ \\
	
	\begin{mydef}
		A concatenation of two Transformulas 
		\begin{equation*}
		\psi_{1 \circ 2} = \psi_1 \circ \psi_2 = (\invars_{1 \circ 2}, \outvars_{1 \circ 2}, \auxvars_{1 \circ 2}, \varphi_{1 \circ 2}, \widehat{\varphi}_{1 \circ 2})
		\end{equation*}  yields one Transformula describing the behaviour of both of them. With
		\begin{itemize}
			\item $\invars_{1 \circ 2} = \invars_1$
			\item For $\outvars_{1 \circ 2}$ we have to distinguish three cases cases: 
			\begin{itemize}
				
				\item[I:] $(x \mapsto x_i') \in Out_1$ and $x  \not\in entries(Out_2)$, meaning program variable is solely modified in $\psi_1$. In that case the out-variable of the concatenation is the same as the out-variable of $\psi_1: $ $\outvars_{1 \circ 2} \cup (x \mapsto x_i')$ 
				\item[II:] $(x \mapsto x_j') \in Out_2$ and $x  \not\in entries(Out_1)$, meaning program variable is solely modified in $\psi_2$. In that case the out variable of the concatenation is the same as the out-variable of $\psi_2: $ $\outvars_{1 \circ 2} \cup (x \mapsto x_j')$ 
				\item[III:] $x \in entries(Out_1)$ and $x \in entries(Out_2)$, meaning program variable $x$ is modified in both transformulas which can create a term variable naming conflict. 
				In this case $\outvars_{1 \circ 2} \cup (x \mapsto \widehat{x_j}')$ where $\widehat{x_j}'$ is a fresh term variable that has not been used before.
				
			\end{itemize}

			\item $\auxvars_{1 \circ 2} = \{ \widehat{v_i} \ |\ v_i \in \auxvars_1 \cup \auxvars_2 \cup range(\invars_2) \text{ where } \widehat{v_i} \text{ is a fresh variable of } v_i \}$
			\item $\varphi_{1 \circ 2}$ = $\varphi_1[x_i' / x_j, v_i / \widehat{v_i} ] \land \varphi_2[v_j / \widehat{v_j}, x_j' / \widehat{x_j}']$, where
			 \begin{itemize}
				\item $\varphi_1[x_i' / x_j, v_i / \widehat{v_i} ] $ is $\varphi_1$ where we substitute every program variable mapping $(x \mapsto x_i') \in \outvars_1$ with $(x \mapsto x_j) \in \invars_2$ and each $v_i \in \auxvars_1$ with a fresh variable $\widehat{v_i}$.
				\item  $\varphi_2[v_j / \widehat{v_j}, x_j / \widehat{x_j}]$ is $\varphi_2$ where we substitute each $v_j \in \auxvars_2$ with a fresh variable $\widehat{v_j}$ and each mapping $(x \mapsto x_j') \in \outvars_2$, that fulfills out-variable case $III$, with $(x \mapsto \widehat{x_j}')$.
			\end{itemize} 
			
			%is the conjunction of $\varphi_1$ in which we replace every $(x, x_i) \in \outvars_0$ with $(PV, TV_2) \in \invars_2$ and each $v_1 \in \auxvars_1$ with a fresh variable $v_1'$ %and $\varphi_2$ in which we too replace each $v_2 \ in \auxvars_2$ with a fresh variable $v_2'$ and we replace each $(PV, TV_2) \in \outvars_2$ with a fresh variable $TV_2'$.
			\item $\widehat{\varphi}_{1 \circ 2}$ is the closed formula of $\varphi_{1 \circ 2}$ where every in-variable is replaced by the unprimed constant of the corresponding program variable and every out-variable is replaced by the primed constant. For every every $v_i \in \auxvars_{1 \circ 2}$ we introduce a fresh constant.
		\end{itemize}
	\end{mydef}

	\smallskip
	Using this definition we get $\psi_2 = \psi_0 \circ \psi_1$ with
	\begin{itemize}
		\item $\invars_2 = \invars_0 = \emptyset$
		\item $\outvars_2 = \{ x \mapsto x_3', y \mapsto y_3' \}$ \\ where $x_3'$ and $y_3'$ are new term variables because $x$ and $y$ are changed in both $\psi_0$ and $\psi_1$.
		\item $\auxvars_2 = \{x_1, y_1 \} $
		\item $\varphi_2 = (x_1 = 0 \land y_1 = 0 \land x_3' = x_1 + 1 \land y_3' = x_3' + y_1)$
		\item $\widehat{\varphi_2} = (c_1 = 0 \land c_2 = 0 \land c_x' = c_1 + 1 \land c'_y = c_x' + c_2)$ \\ We generated new constants for each aux-var: \\
		$x_1 \mapsto c_1, y_1 \mapsto c_2$
	\end{itemize}
	With this concatenation we can reduce $CFG_{0+1}$ from three locations and two TFs to two locations and only one TF $\psi_2$: \\
	
	\begin{figure}[H]
		\centering
		\begin{tikzpicture}[%
		->,
		>=stealth', shorten >=1pt, auto,
		node distance=3cm, scale=1, 
		transform shape, align=center,    
		smallnode/.style={inner sep=1.4}
		]
		\node[state](1){$\ell_0$};
		
		\node[state] (2) [below of=1] {$\ell_2$};
		
		\path (1) edge node {%
			$
			\psi_2 := \left\{
			\begin{array}{lcl}
			\invars       & = & \emptyset \\
			\outvars      & = & \{ x \mapsto x_3', y \mapsto y_3' \} \\
			\auxvars      & = &  \{x_1, y_1 \} \\
			\varphi       & = & x_1 = 0 \land y_1 = 0 \land x_3' = x_1 + 1 \land y_3' = x_3' + y_1 \\
			\widehat{\varphi} & = & c_1 = 0 \land c_2 = 0 \land c_x' = c_1 + 1 \land c'_y = c_x' + c_2 \\
			\end{array}
			\right.
			$ %
		} (2)
		;
		
		
		);
		\end{tikzpicture}
		\caption{Reduced CFG $G_{0+1}$.}
	\end{figure}

	\subsection{Interprocedual Control Flow Graphs}
	
	We want to be able to handle programs that consist of procedures that call other procedures, so called interprocedual programs, for that we need to modify our definitions from the previous chapter.
	
	\begin{mydef}
		An interprocedual control flow graph (ICFG) is a tuple \\$IG = (Loc, \Delta, \ell_{init}, \ell_E, st, proc)$ where $Loc$, $\Delta$, $\ell_{init}$, $\ell_E$, and st have the same definition as in regular CFGs. $proc$ is a set of different procedures found in the program. 
		%where transitions $(\ell, \ell' \in \Delta)$ are not only internal transitions but also call and return transitions. An ICFG can contain more than one procedure and with that being %able to represent programs that have more than one procedure as well.
	\end{mydef}
	In addition to the transitions we have seen before, ICFGs feature two new kinds that lead the control flow from one procedure of the program to another.
	\begin{mydef} Assume we are given an ICFG $IG = (Loc, \Delta, \ell_{init}, \ell_E, st, proc)$, we find three distinct classes of program transitions in $\Delta$:
		\begin{itemize}
			\item Internal transitions: An internal transition $(\ell, \ell') \in \Delta$ is a program transition where both $\ell$ and $\ell'$ are part of the same procedure. $st(\ell, \ell')$ is a transformula describing the change in variables.
			
			\item Call transitions:  A call transition leads the control flow from one procedure to another. We define that each procedure $p \in proc$ has a unique entry location $\ell^{entry}_p$. A transition $(\ell, \ell') \in \Delta$ is called a call transition, if $\ell$ is a location in procedure $p$ and $\ell'$ is the entry location of another procedure $q \in proc$. \\ $st(\ell, \ell')$ consists of three transformulas that function as a connection between $p$ and $q$, \\ $\psi_{old}, \psi_{global}$ and $\psi_{local}$: 
			\begin{itemize}
				\item$\psi_{old}$: Assuming we have global variables $g_0, ..., g_n$ that are modified by the procedure $q$. $\psi_{old}$ is a conjunction of assignments of each $g_i$ to a fresh variable $old_{i}$. 
				\item $\psi_{global}$: Reverse transformula of $\psi_{old}$ assigning the old variables $old_i$ back to its global counterparts $g_i$.
				\item $\psi_{local}$: Assuming we have an assignment where a local variable $x$ of procedure $p$ is used and modified by $q$. For example $x := $\texttt{foo(x)}, where \texttt{foo} increases $x$ by 10. \\
				In that case $\psi_{local}$ maps $x$ to the input variable of $q$.
			\end{itemize} 
			
			\item Return transitions: A return transition leads the control flow from one called procedure back to the caller procedure. We define that each procedure $p \in proc$ has one unique exit location $\ell^{exit}_p$. A transition $(\ell, \ell') \in \Delta$ is called a return transition, if $\ell$ is the exit location $\ell_q^{exit}$ of procedure $q \in proc$ and $\ell'$ is a location of caller procedure $p$. There is a map that maps each return to its corresponding call. \\
			$st(\ell, \ell')$ consists of transformula $\psi_{ass}$:
			\begin{itemize}
				\item $\psi_{return}$: In case that a local variable $x$ of $p$ was used and modified by $q$, $\psi_{return}$ maps the output of $q$ back to $x$.
			\end{itemize}
		\end{itemize}
	\end{mydef}
	
	Assume we are given program $P_2$ that is represented by ICFG $IG_2 = (Loc_2, \Delta_2, \ell_{init}, \ell_E, st_2, proc_2)$
	\begin{itemize}
		\item  $Loc_2= \{ main_0, main_1,  main_2, inc_1, inc_2 \} $
		\item $\Delta_2 = \{ (main_0, main_1), ( main_1, inc_0), (inc_0, inc_1), (inc_1, main_2)\}$
		\item $\ell_{init} = main_0$ 
		\item $\ell_E = \emptyset$
		\item $st_2 = (main_0, main_1) \mapsto \psi_0, (main_1, inc_1) \mapsto \psi_{global}, (main_1, inc_1) \mapsto \psi_{old}, (inc_0, inc_1) \mapsto \psi_1,  (inc_1, main_2) \mapsto \psi_{return})$
		\item $proc_2 = \{ main(), inc()\}$
	\end{itemize} 
	\bigskip
	
	\begin{minipage}{.3\textwidth}
		\centering
		\begin{align*}
		&\texttt{x, y : int}; \\ \\
		&\texttt{procedure main():} \\
		&\texttt{\hspace*{1em}1:  x := 0}; \\
		&\texttt{\hspace*{1em}2:  y := 0;} \\
		&\texttt{\hspace*{1em}3: call inc();} \\ \\
		&\texttt{procedure inc():} \\
		&\texttt{\hspace*{1em}1: y:= y\ +\ 1;} \\
		\end{align*}
		
		\captionof{figure}{Program $P_2$}
		\label{fig:square}
	\end{minipage}%
	\hfill
	\begin{minipage}{.6\textwidth}
		\centering
		\begin{tikzpicture}[%
		->,
		>=stealth', shorten >=1pt, auto,
		node distance=3cm, scale=1, 
		transform shape, align=center,    
		smallnode/.style={inner sep=1.4}
		]
		\node[state](1){$main_0$};
		
		\node[state] (2) [below of=1] {$main_1$};
		
		\node[state] (3) [below=15em of 2] {$inc_0$};
		
		\node[state] (4) [below of=3] {$inc_1$};
		
		\node[state] (5) [below of=4] {$main_2$};
		
		\path (1) edge node {%
			$
			\psi_0 := \left\{
			\begin{array}{lcl}
			\invars       & = & \emptyset \\
			\outvars      & = & \{ x \mapsto x_{0}' , y \mapsto y_{0}' \} \\
			\auxvars      & = & \emptyset \\
			\varphi       & = & x_{0}' = 0 \; \land \; y_{0}' = 0 \\
			\widehat{\varphi} & = & c_{x}' = 0 \;\land\; c_{y}' = 0 \\
			\end{array}
			\right.
			$ %
		} (2)
		;
		\path (2)[densely dotted] edge node {%
			$
			\psi_{global} := \left\{
			\begin{array}{lcl}
			\invars       & = & \{y_{old} \mapsto y_{old_0} \} \\
			\outvars      & = & \{ y \mapsto y_0', \ y_{old} \mapsto y_{old_0}' \} \\
			\auxvars      & = & \emptyset \\
			\varphi       & = & y_0 = y_{old_0}' \\
			\widehat{\varphi} & = & c_{y}' = c_{old_y} \\
			\end{array}
			\right.
			$ %
		} ($(2)!0.5!(3)$) edge[densely dotted] node[right=0.42\textwidth, below] {%
			$
			\psi_{old} := \left\{
			\begin{array}{lcl}
			\invars       & = & \{y \mapsto y_{0} \} \\
			\outvars      & = & \{ y \mapsto y_{0}', \ y_{old} \mapsto y_{old_1}' \} \\
			\auxvars      & = & \emptyset \\
			\varphi       & = & y_{old_1}' = y_{0} \\
			\widehat{\varphi} & = & c_{y_{old}}' = c_{y} \\
			\end{array}
			\right.
			$ } (3)
	
		;
		\path (3) edge node {%
			$
			\psi_{1} := \left\{
			\begin{array}{lcl}
			\invars       & = & \{ y_{old} \mapsto y_{old_0} \} \\
			\outvars      & = & \{ y \mapsto y_{0}' \} \\
			\auxvars      & = & \emptyset \\
			\varphi       & = & \; y_{0}' = y_{old_0} + 1 \\
			\widehat{\varphi} & = & c_{y}' = c_{old_y} + 1 \\
		\end{array}
			\right.
			$ %
		} (4)
		;
		\path (4)[densely dotted] edge node {%
			$
			\psi_{return} := \left\{
			\begin{array}{lcl}
			\invars       & = & \emptyset \\
			\outvars      & = & \emptyset \\
			\auxvars      & = & \emptyset \\
			\varphi       & = & true\\
			\widehat{\varphi} & = & true \\
			\end{array}
			\right.
			$ %
		} (5)
		;
		);
		\end{tikzpicture}
		\captionof{figure}{$IG_2$}
		\label{fig:rect}
	\end{minipage}%
	
	\pagebreak
	$P_2$ consists of two procedures, \texttt{main()} and \texttt{inc()}, that change the global variables $x$ and $y$. Note that we omit $\psi_{local}$ in this case because no local variables are used.
	\jw{more details + example with local vars.}
	
	
	\pagebreak
	
	
	\subsection{Interpolation}
	Interpolants are used as a way of covering a more general state space. There are multiple ways of finding interpolants for given formulas.
	In the following we will introduce two techniques: Craig interpolation and Selfless interpolation. 
	\jw{citation needed}
	
	\begin{mydef}
		Let $(A, B)$ be a pair of formulas such that $A \land B$ is unsatisfiable. A Craig interpolant $I$ for $(A, B)$ is a formula fulfilling the following characteristics:
		\begin{itemize}
			\item $A \Rightarrow I$
			\item $I \land B$ is unsatisfiable
			\item $I$ consists only of variables found in $A \cap B$
		\end{itemize}
	\end{mydef}

	\pagebreak
	
	%-------------------------------------------------%
	\section{PDR in Ultimate}
	%-------------------------------------------------%
	In this section we swiftly introduce our PDR implementation, describe how it works, and introduce the problems we solved in this project.
	
	\subsection{PDR for Software}
	PDR was first devised as a means of hardware verification, however in my 2018 Bachelor's Thesis we proposed a way of using it on software. This approach was based on the technique described by Lange et al \cite{DBLP:conf/fmcad/0001NN15}.
	Instead of unrolling the transition relation of a given program's CFG, like other verification techniques, PDR checks only local transitions in a backwards-search like manner. \\ \\
	Given a program $P$ and its CFG  $G = (Loc, \Delta, \ell_{init}, \ell_E, st)$. To check correctness of $P$ PDR uses an array of so called \textsl{frames} for each program location $\ell \in Loc$. 
	\begin{mydef}
		A frame $F_{i,\ell}$ is a predicate mapped to a program location $\ell$ and an iteration of PDR, called level, $i$.
		Every program location $\ell \in Loc$ is assigned its own array of frames. These are used to overapproximate reachable states from the corresponding location.
	\end{mydef}
	Furthermore to check reachability of error state $\ell_E$ PDR maintains a stack of so called \textsl{proof-obligations}.
	\begin{mydef}
		A proof-obligation is a triple po = $(p, \ell, i)$ with a predicate $p$, a program location $\ell$, and a called level, $i$
		As the name suggests proof-obligations have to be proven. This is done by checking if $p$ is reachable at the given program location on the level $i$. If it is possible to generate a proof-obligation on level $i = 0$ we can say that $\ell_E$ is reachable from the initial state making the program unsafe.
	\end{mydef}

	Before entering the first iteration PDR initializes the first frame for each program location as $\{ false \}$ except the initial location whose frame is $\{ true \}$. \\ \\
	
	Starting a new iteration PDR adds a new frame to the program locations. This new frame is initialized as $\{true\}$ for every location. After this PDR generates its first proof-obligations: For every transition $(\ell, \ell_E) \in \Delta$ add new proof-obligation $(p, \ell, 1)$, $p$ being the transformula $st(\ell, \ell_E)$, to the proof-obligation stack. With the now no longer empty stack PDR enters the main loop which is divided into two phases: the \textsl{blocking-phase}, and \textsl{propagation-phase}.
	
	\bigskip
	
	First the blocking-phase: \\ 
	Given a proof-obligation $po_1 = (p, \ell, i)$ from the stack, the goal is to prove that the predicate $p$ is not reachable in $\ell$ on level $i$. \\ To verify that PDR constructs the following conjunction:
	\begin{equation*}
		F_{i - 1, \ell_{pre}} \land st(\ell_{pre}, \ell) \land p'
	\end{equation*}
	For every location $\ell_{pre}$ where $(\ell_{pre}, \ell) \in \Delta$. With 
	\begin{itemize}
		\item $F_{i - 1, \ell_{pre}}$ being the frame of $\ell_{pre}$ at level $i - 1$.
		\item $st(\ell_{pre}, \ell)$ being the transformula assigned to transition $(\ell_{pre}, \ell)$
		\item $p'$ being the primed variant of $p$. Every termvariable in $p$ has been substituted by the corresponding primed out-variable of $st(\ell_{pre}, \ell)$
	\end{itemize}
	This conjunction is checked for satisfiability by an SMT-solver.
	\begin{itemize}
		\item If unsatisfiable: PDR blocks the proof-obligation by updating $F_{i, \ell} = F_{i, \ell} \land \neg p$. \\ In case there is a future proof-obligation $(p, ell_{succ}, i + 1)$ for a successor $\ell_{succ}$ of $\ell$ generated, then PDR knows already that $p$ is not reachable. The proof-obligation is discarded form the stack.
		\item If satisfiable: PDR cannot prove that the proof-obligation is unreachable yet. Generate a new proof-obligation $po_i = (pre(st(\ell_{pre}, \ell), p), \ell_{pre}, i-1) $ for each predecessor location $\ell_{pre}$ of $\ell$, with $pre(st(\ell_{pre}, \ell), p)$ being the precondition of transformula $st(\ell_{pre}, \ell)$ and $p$. Both the new proof-obligations and the old proof-obligation are added on top of the proof-obligation stack.
	\end{itemize}
	This continues until there is a proof-obligation with level 0, proving the program unsafe, or the stack becomes empty.
	\bigskip
	
	If the proof-obligation stack could be emptied PDR enters the propagation-phase where it iterates through the frames of the program locations to find a fixpoint. \\
	\begin{mydef}
		We call a level $i$ where $F_{i, \ell} = F_{i-1, \ell}$ for every location $\ell \in Loc$ a fixpoint for the frame array. If there is a fixpoint the program is safe.
	\end{mydef}
	If there is neither a proof-obligation on level 0 or a fixpoint PDR starts the next iteration on an incremented level.
	
	\jw{Say that the termvariables in the frames are being substituted by the in-variables of TF}
	
	\bigskip
	
	\subsection*{Example:}
	To illustrate the functionality of our PDR library further consider program $P_3$ with corresponding CFG $ G_3 = (Loc_3, \Delta_3, \ell_{init}, \ell_E, st) $ with \\ 
	\begin{itemize}
		\item $Loc_3 = \{\ell_0, \ell_1, \ell_E \}$
		\item $\Delta_3 = \{(\ell_0, \ell_1), (\ell_1, \ell_1), (\ell_1, \ell_E) \}$
		\item $\ell_{init} = \ell_0 $
		\item $\ell_E = \ell_E$
		\item $st = ( (\ell_0, \ell_1) \mapsto \psi_0, (\ell_1, \ell_1) \mapsto \psi_1, (\ell_1, \ell_E) \mapsto \psi_E)$
	\end{itemize}

	\begin{minipage}{.3\textwidth}
	\centering
	\begin{align*}
	&\texttt{1: x, y : int}; \\
	&\texttt{2: x := 0}; \\
	&\texttt{3: y := x}; \\
	&\texttt{4: while(*) \{} \\
	&\texttt{5:} \hspace*{2em} \texttt{x := x + 1}; \\
	&\texttt{6:} \hspace*{2em} \texttt{y := y + 1;} \\
	&\texttt{7: \}} \\
	& \texttt{8: assert(x == y)}
	\end{align*}
	
	
	
	\captionof{figure}{Program $P_{3}$}
	\label{fig:square}
\end{minipage}%
\hfill
\begin{minipage}{.6\textwidth}
		\centering
		\hspace*{-1em}
		\begin{tikzpicture}[%
		->,
		>=stealth', shorten >=1pt, auto,
		node distance=5cm, scale=1, 
		transform shape, align=center,    
		smallnode/.style={inner sep=1.4}
		]
		\node [state](1){$\ell_0$};
		
		\node[state] (2) [below of=1] {$\ell_1$};
		
		\node[state] (4) [below of=2] {$\ell_E$};
		
		
		
		\path (1) edge node {%
			$
			\psi_{0} := \left\{
			\begin{array}{lcl}
			\invars       & = & \emptyset \\
			\outvars      & = & \{x \mapsto x_0', y \mapsto y_0' \} \\
			\auxvars      & = & \emptyset \\
			\varphi       & = & x_0' = 0\ \land\ y_0' = x_0' \\
			\widehat{\varphi} & = & c_x' = 0 \ \land \ c_{y}' = c_{x}' \\
			\end{array}
			\right.
			$ %
		} (2)
		(2) edge [loop right] node { $
			\psi_{1} := \left\{
			\begin{array}{lcl}
			\invars       & = & \{ x \mapsto x_0, y \mapsto y_0 \} \\
			\outvars      & = & \{ x \mapsto x_1', y \mapsto y_1' \} \\
			\auxvars      & = & \emptyset \\
			\varphi       & = & x_1' = x_0 + 1\ \land\ y_1' = y_0 + 1 \\
			\widehat{\varphi} & = & c_x' = c_x + 1 \ \land \ c_{y}' = c_{y} + 1 \\
			\end{array}
			\right.
			$} (2)
		(2) edge node {$
			\psi_{E} := \left\{
			\begin{array}{lcl}
			\invars       & = & \{ x \mapsto x_0, y \mapsto y_0 \} \\
			\outvars      & = & \emptyset \\
			\auxvars      & = & \emptyset \\
			\varphi       & = & x_0 \neq y_0 \\
			\widehat{\varphi} & = & c_x \neq c_{y} \\
			\end{array}
			\right.
			$ } (4)
		;
		
		
		);
		\end{tikzpicture}
		\captionof{figure}{$G_3$}
	\label{ex1} 
\end{minipage}% \\
\vspace*{3em} \\
	Note that $\psi_0$ and $\psi_1$ represent the concatenation of transformulas relating to the assignments in line 2, 3 and 5, 6 respectively. \\
	To verify whether it is possible to violate the assertion in line 8 we use PDR to check the reachability of $\ell_E$. \\ \par
	
	\textbf{1. Step: Check for 0-Counter-Example} \\
	Is the initial location also the error location?
	No, we continue with initializing level 0 by adding to each $\ell \in L \backslash \{\ell_0, \ell_E\}$ a new frame $F_{0, \ell} = false$, for $\ell_0$ generating $F_{0, \ell_0} = true$. \\ \\
	
	
	\setlength\tabcolsep{0.35em}
	\begin{center}
		\begin{tabu}{cc}
			\toprule
			& level \\
			\cmidrule(lr){2-2}
			location & 0 \\
			\cmidrule{1-2}
			$\ell_0$ & $true$ \\
			$\ell_1$ & $false$ \\
			\bottomrule
		\end{tabu}
	\end{center}
	
	\hspace*{5cm}
	
	
	\textbf{2. Step: Next Level} \\
	We initialize new frames for level 1 as \texttt{true}: \\
	
	\begin{center}
		\begin{tabu}{ccc}
			\toprule
			& \multicolumn{2}{c}{level} \\ 
			\cmidrule(lr){2-3}
			location & 0 & 1 \\
			\cmidrule{1-3}
			$\ell_0$ & $true$ & $true$ \\
			$\ell_1$ & $false$ & $true$ \\
			\bottomrule
		\end{tabu}
	\end{center}
	
	\hspace*{5cm}
	
	
	We see there is only one transition leading to $\ell_E$, $(\ell_1, x \neq y, \ell_E)$. We get the initial proof-obligation $(x \neq y, \ell_1, 1)$. \\ \\ \par
	\textbf{3. Step: First Blocking Phase} \\
	To block the initial proof-obligation $(x \neq y, \ell_1, 1)$ we have to check the two predecessors of $\ell_1$:
	
	\begin{itemize}
		\item predecessor: $\ell_0$
		\begin{equation*}
		\underbrace{true}_{F_{0, \ell_0}} \; \land \; \underbrace{x_0' = 0\ \land\ y_0' = x_0'}_{st(\ell_0, \ell_1)\; = \; \psi_0} \land \; \underbrace{x_0' \neq y_0'}_{p'}
		\end{equation*}
		Which is unsatisfiable, we update our frames with $\neg p = \neg{(x \neq y)} \equiv (x = y)$ to $F_{0, \ell_1}$ and $F_{1, \ell_1}$: \\
		
		\begin{center}
			\begin{tabu}{ccc}
				\toprule
				& \multicolumn{2}{c}{level} \\
				\cmidrule(lr){2-3}
				location & 0 & 1 \\
				\cmidrule{1-3}
				$\ell_0$ & $true$ & $true$ \\
				$\ell_1$ & $false \land x = y$ & $true \land x = y$ \\
				\bottomrule
			\end{tabu}
		\end{center}
		
		\hspace*{5cm}
		
		\item predecessor: $\ell_1$
		\begin{equation*}
		\underbrace{false \; \land \; x_0 = y_0}_{F_{0, \ell_1}} \; \land \; \underbrace{x_1' = x_0 + 1 \land y_1' = y_0 + 1'}_{st(\ell_1, \ell_1)\; = \; \psi_{1}} \land \; \underbrace{ x_1' \neq y_1'}_{p'}
		\end{equation*}
		Which is unsatisfiable as well, but because $x = y$ has already been added to $F_{0, \ell_1}$ and $F_{1, \ell_1}$. The initial proof-obligation has been blocked and can be removed from the obligation stack.
		
	\end{itemize}
	Because the stack is now empty, we continue with the first propagation-phase. \\ \\ \par
	
	\textbf{4. Step: First Propagation-Phase} \\
	Check if there exists a global fixpoint $i$ where
	\begin{equation*}
	F_{i-1, \ell} = F_{i, \ell}
	\end{equation*}
	for every location $\ell \in L \backslash \{l_E \}$. \\
	We see there is no such $i$, we continue with the next level. \\ \\ \par
	
	\textbf{5. Step: Next Level} \\
	We initialize new frames for level 2 as \texttt{true}: \\
	
	\begin{center}
		\begin{tabu}{cccc}
			\toprule
			& \multicolumn{3}{c}{level} \\
			\cmidrule(lr){2-4}
			location & 0 & 1 & 2\\
			\cmidrule{1-4}
			$\ell_0$ & $true$ & $true$ & $true$ \\
			$\ell_1$ & $false$ & $x = y$ & $true$\\
			\bottomrule
		\end{tabu}
	\end{center}
	
	\hspace*{5cm}
	
	Again we generate the initial proof-obligation which is the same as before but on level 2. We have to block the initial proof-obligation $(x \neq y, \ell_1, 2).$ \\ \\ \par
	
	
	\textbf{6. Step: Second Blocking Phase} \\
	To block proof-obligation $(x \neq y, \ell_1, 2)$ we check the predecessors of $\ell_1$:
	
	\begin{itemize}
		\item predecessor: $\ell_0$
		\begin{equation*}
		\underbrace{true}_{F_{1, \ell_0}}\; \land \; \underbrace{x_0' = 0\ \land\ y_0' = x_0'}_{st(\ell_0, \ell_1)\; = \; \psi_0} \; \land \;  \underbrace{x_0' \neq y_0'}_{p'}
		\end{equation*}
		Which is unsatisfiable, we update our frames with $\neg (x \neq y) \equiv x = y$ to $F_{0, \ell_1}$, $F_{1, \ell_1}$ and $F_{2, \ell_1}$:
		
		\begin{center}
			\begin{tabu}{cccc}
				\toprule
				& \multicolumn{3}{c}{level} \\
				\cmidrule(lr){2-4}
				location & 0 & 1 & 2\\
				\cmidrule{1-4}
				$\ell_0$ & $true$ & $true$ & $true$ \\
				$\ell_1$ & $false$ & $x = y$ & $true \land x = y$ \\
				\bottomrule
			\end{tabu}
		\end{center}
		
		\hspace*{5cm}
		
		\item predecessor: $\ell_1$
		\begin{equation*}
		\underbrace{x_0 = y_0}_{F_{1, \ell_1}} \; \land \; \underbrace{x_1' = x_0 + 1 \land y_1' = y_0 + 1'}_{st(\ell_1, \ell_1)\; = \; \psi_{1}} \; \land  \; x_1' \neq y_1'
		\end{equation*}
		Which is unsatisfiable as well, but because $x = y$ has already been added to $F_{0, \ell_1}$, $F_{1, \ell_1}$, and $F_{2, \ell_1}$ we move on.
	\end{itemize}
	
	As there are no proof-obligations left, we continue with the second propagation-phase \\ \\ \par
	
	\textbf{7. Step: Second Propagation-Phase} \\
	
	\begin{center}
		\begin{tabu}{cccc}
			\toprule
			& \multicolumn{3}{c}{level} \\
			\cmidrule(lr){2-4}
			location & 0 & 1 & 2\\
			\cmidrule{1-4}
			$\ell_0$ & $true$ & $true$ & $true$ \\
			$\ell_1$ & $false$ & $x = y$ & $x = y$ \\
			\bottomrule
			\multicolumn{1}{c}{} &  \multicolumn{1}{c}{} & \multicolumn{2}{c}{\upbracefill} \\[-1ex]
			\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{2}{c}{$\scriptstyle global\ fixpoint$}\\
		\end{tabu}
	\end{center}
	
	\hspace*{5cm}
	
	We see that level 1 equals level 2 on all locations, with that we found global fixpoint position $i = 2$, the forumulas at that position are the inductive invariants proving that $\ell_E$ is not reachable.
	
	\section{Interprocedual PDR}
	
	
	\subsection{title}
	
	
	\section{Using Interpolants}
	Adding the negated proof-obligation to the frames works well in most cases. Consider program $\mathcal{A}$ in Figure 3.4. The initial proof-obligation on level $i$ is $(x = 1, \ell_1, i)$, because $\ell_1$ has two predecessors we have to check:
	\begin{equation}
	F_{\ell_1, i - 1} \land x' = x + 1 \land x' = 1
	\end{equation}
	\begin{equation}
	F_{\ell_0, i - 1} \land x' = 2 \land x' = 1
	\end{equation}
	for satisfiability. \\
	Formula (3.1) is satisfiable until we get a proof-obligation on level 1, because frame $F_{\ell_1, 0}$ is always false. \\
	Formula (3.2) is always unsatisfiable, in each level we add $x \neq 1$ to $\ell_1$'s frames. That formula however is not strong enough to block the chain of satisfiable obligations of (3.1) in the next level, which is inefficient.
	
	
	
	\section{Evaluation}
	Run the benchmarks again and compare them to the ones from last year, where we will see (hopefully) a speedup.
	
	\pagebreak
	
\addcontentsline{toc}{chapter}{Bibliography}
\bibliographystyle{plain}
\bibliography{bib}

	
\end{document}