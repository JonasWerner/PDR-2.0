\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage{xspace}
\usepackage{tabu}
\usepackage[%
  hyperindex,%
  plainpages=false,%
  pdfusetitle]{hyperref}
\usepackage[all]{hypcap}
\usepackage{cite}
\usepackage{booktabs}
\usepackage{url}
\usepackage{listings}
\usepackage{enumitem}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{tikz}
\usetikzlibrary{positioning,shapes.geometric, arrows,automata, decorations.pathreplacing}
\usepackage{pgf}
\usepackage{slantsc}
\usepackage{geometry}
\usepackage{amssymb}
\usepackage{subcaption}
\usepackage{float}


\usepackage[%disable,%
  colorinlistoftodos,%
  color=cyan!50!white,%
  bordercolor=cyan!50!black]{todonotes}

%%%%%%%%%%%% Colors 
%% a somewhat friendly scheme for 5 different colors 
\definecolor{g1}		{RGB}{215,25,28} % a kind of red
\definecolor{g2}		{RGB}{253,174,97} % a kind of orange
\definecolor{g3}		{RGB}{255,255,191} % a kind of yellow
\definecolor{g4}		{RGB}{171,217,233} % a kind of light blue 
\definecolor{g5}		{RGB}{44,123,182} % a kind of dark blue 

\definecolor{gr1}		{RGB}{250, 250, 250}
\definecolor{gr2}		{RGB}{229, 229, 229} % some grey

% color of interpolants
\definecolor{grey}{RGB}{200,200,200}

%color for pictures
\colorlet{outlineblue}		{g5}
\colorlet{fillblue}			{g4}
\colorlet{darkback}			{gr2}
\colorlet{lightback}		{gr1}
\colorlet{stmtcolor}		{gr2} %default statement color
\colorlet{subgraphcolor}	{g3} %default statement color


%%%%%%%%%%%% Setup
\newtheorem{name}{Printed output}
\newtheorem{mydef}{Definition}

\hypersetup{
colorlinks=true,        % false: boxed links; true: colored links
linkcolor=g1,        % color of internal links
citecolor=g1,        % color of links to bibliography
filecolor=g1,        % color of file links
urlcolor=g1          % color of external links
}


\lstdefinestyle{boogie}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  xleftmargin=\parindent,
  showstringspaces=false,
  basicstyle=\footnotesize\ttfamily,
  numbers=left,
  xleftmargin=.6cm
}

\lstset{escapechar=@,style=boogie}

%%%%%%%%%%%% Comments
\newif\iffinal
%\finaltrue % comment out to remove comments 
 
\iffinal
\newcommand\mycom[1]{}
\else
\newcommand\mycom[1]{#1}
\overfullrule=1mm
\fi
\setlength\parindent{0pt}

\newcommand{\jw}[1]{\mycom{\todo[color=blue!40,inline]{\small JW: #1}}}
\newcommand{\jwl}[1]{\mycom{\todo[color=blue!40,inline,caption={Beschreibung},nolist]{\small #1}}}
\newcommand{\dd}[1]{\mycom{\todo[color=orange!40,inline]{\small DD: #1}}}
\newcommand{\ddl}[1]{\mycom{\todo[color=orange!40,inline,caption={Beschreibung},nolist]{\small #1}}}

\newcommand{\all}[1]{\mycom{\todo[color=green!40,inline]{\small #1}}}
\newcommand{\meta}[1]{\mycom{\todo[color=blue!10,inline,caption={Beschreibung},nolist]{\setlist{nolistsep}\small #1}}}
\newcommand{\xxx}{\mycom{\stfootcol{Placeholder}{blue!20}\xspace}}
\newcommand{\cn}{\mycom{\stfootcol{Cite}{blue!20}\xspace}}


%%%%%%%%%%%% Actual content
\begin{document}
	\newcommand{\HorizontalLine}{\rule{\linewidth}{0.3mm}}
	
	\title{ \HorizontalLine \\ \textbf{Interprocedual and Interpolating \\ Property Directed Reachability in \textsc{Ultimate}} \HorizontalLine}
	

	
	\author{Jonas Werner \\ Dr. Daniel Dietsch}


	
	\date{} 
	
	\maketitle
	
	\begin{abstract}
	In a previous project we implemented a library using PDR for software verification in the program analysis framework ULTIMATE. However \jw{...}
	\end{abstract}
	
	
	%-------------------------------------------------%
	\section{Introduction}
	%-------------------------------------------------%
	
	Property Directed Reachability (PDR) was first devised as a hardware verification paradigm by Aaron Bradley \cite{DBLP:conf/vmcai/Bradley11}. It however showed potential as a software verification method as well.
	In the course of my 2018 Bachelor's Thesis we devised a method of using Property Directed Reachability on software in the software analysis framework \textsc{Ultimate} \cite{Zitat02}. \\
	Our approach was based on the technique described by Lange et al \cite{DBLP:conf/date/WelpK13}. \\ The implementation worked however solely on intraprocedual programs, meaning that if we encountered a call to another procedure, it would no longer continue the verification process. \\
	Furthermore our implementation did not make use of interpolants which broaden the state space covered by blocked proof-obligations. \\
	This project aims at expanding PDR with both interprocedual analysis capabilities and usage of interpolants. \jw{\textbf{Both kinds of interpolants: Craig and selfless (citation needed)}} \par
    This paper is structured as follows, firstly we will give some background definition of interprocedual program analysis, and interpolants, then we will describe our changes made to our PDR library.
	
	%-------------------------------------------------%
	\section{Background}
	%-------------------------------------------------%
	In this section we will give preliminary definitions on what interprocedual programs are and what interpolants we use.
	
    
    \newcommand{\tf}{\ensuremath{\varphi}\xspace}
    \newcommand{\ctf}{\ensuremath{\widehat{\varphi}}\xspace}
    \newcommand{\invars}{\ensuremath{In}\xspace}
    \newcommand{\outvars}{\ensuremath{Out}\xspace}
    \newcommand{\auxvars}{\ensuremath{Aux}\xspace}
	
	\subsection{Control Flow Graphs}	
	Given a program we need a way to model its control flow to check whether given error states can be reachable or not, for that we introduce control flow graphs.
	
	\begin{mydef}
	Each program variable $(PV)$ $x$, is mapped to a tuple $(proc, tv, c, c')$ that consists of: 
		\begin{itemize}
			\item A label $proc$ that assigns the name of the corresponding procedure in which the program variable occurs. 
			%If the program variable is a global variable, $proc = null$
			\item A termvariable (TV) $x_0$ that is used in term operations and SMT calls.
			\item A constant $c_x$
			\item A primed constant $c_x'$
		\end{itemize}
	\end{mydef}
	For example, assume we have the local variable $x$ that is used in procedure $foo$. $x$ is mapped to the tuple $(foo, x_0, c_x, c'_x)$. 
	%\begin{itemize}
	%	\item $proc(x) = foo$
	%	\item $tv(x) = t_x$
	%	\item constant of x: $c_x$
	%	\item primed constant of x: $c'_x$
	%\end{itemize} 
	
	\begin{mydef}
		A predicate $P = (V, \phi, \widehat{\phi})$ is a tuple consisting of: 
		\begin{itemize}
			\item A set of program variables $V$
			\item A formula $\phi$ over the termvariables of the program variables in $V$
			\item A formula $\widehat{\phi}$ which is the closed formula of $\phi$ where every termvariable is replaced by the corresponding program variable unprimed constant.
		\end{itemize}
	\end{mydef}
	

    \begin{mydef}
        A transformula (TF) is a tuple $\psi = (\invars, \outvars, \auxvars, \tf, \ctf)$ with 
        \begin{itemize}
          \item $\invars : PV \rightarrow TV$ is a mapping from program variables to unprimed termvariables called the in-variables
          \item $\outvars : PV \rightarrow TV$ is a mapping from program variables to primed termvariables called the out-variables
          \item $\auxvars \subseteq TV$ is a set of termvariables that only exist in the context of this transformula called the aux-variables,
          \item $\tf$ is a formula over termvariables from $\invars$, $\outvars$, and $\auxvars$. The actual transformula.
          \item $\ctf$ is the closed formula of $\tf$ where every in-variable is replaced by the unprimed constant of the corresponding program variable and every out-variable is replaced by the primed constant of the corresponding program variable.
          %\item $PreProc$ is the procedure in which the program is before executing the TF.
          %\item $SuccProc$ is the procedure the program is in after executing the TF.
        \end{itemize}
    \end{mydef}
    %

	\begin{mydef}
		A control flow graph (CFG) is a directed graph G = ($Loc$, $\Delta$, $\ell_{init}$, $\ell_E$, st) of a program where
		\begin{itemize}
			\item  Loc is a set of program locations
			\item $\Delta$ is a set of internal program transitions consisting of tuples $(\ell, \ell')$ with $\ell, \ell' \in Loc$
			\item $\ell_{init} \in Loc$ is the initial location
			\item $\ell_E \subseteq Loc$ a set of error locations
			\item st: $\Delta \rightarrow \psi$ is a labeling function that assigns each transition in $\Delta$ a transformula.
		\end{itemize}
	\end{mydef} \noindent
	 %
	 \bigskip

	To illustrate these definitions we will present two examples.
	
	\medskip

	\subsection*{Example 1:}
	Assume we are given program $P_0$ that is represented by CFG $G_0$ \\ $G_0 = (\{ \ell_0, \ell_1 \}, \{ (\ell_0, \ell_1)\}, \ell_0, \emptyset, ((\ell_0, \ell_1) 
	\mapsto \psi_0))$

		\begin{minipage}{.3\textwidth}
			\centering
			\begin{align*}
				&\texttt{x, y : int}; \\
				&\texttt{x := 0}; \\
				&\texttt{y := 0;}
			\end{align*}
			
			\captionof{figure}{Program $P_0$}
			\label{fig:square}
		\end{minipage}%
		\hfill
		\begin{minipage}{.6\textwidth}
			\centering
		\begin{tikzpicture}[%
				->,
				>=stealth', shorten >=1pt, auto,
				node distance=3cm, scale=1, 
				transform shape, align=center,    
				smallnode/.style={inner sep=1.4}
				]
				\node[state](1){$\ell_0$};
				
				\node[state] (2) [below of=1] {$\ell_1$};
				
				\path (1) edge node {%
					$
					\psi_0 := \left\{
					\begin{array}{lcl}
					\invars       & = & \emptyset \\
					\outvars      & = & \{ x \mapsto x_{0} , y \mapsto y_{0} \} \\
					\auxvars      & = & \emptyset \\
					\varphi       & = & x_{0} = 0 \; \land \; y_{0} = 0 \\
					\widehat{\varphi} & = & c_{x}' = 0 \;\land\; c_{y}' = 0 \\
					\end{array}
					\right.
					$ %
				} (2)
				;

				);
				\end{tikzpicture}
							\captionof{figure}{$G_0$}
			\label{fig:rect}
		\end{minipage}%
	\bigskip

	Where $\psi_0 = (\invars_0, \outvars_0, \auxvars_0, \varphi_0, \widehat{\varphi}_0)$ is a transformula consisting of: 
	\begin{itemize}
		\item $\invars_0 = \emptyset$. There are no in-variables because $\varphi_0$ does not depend on any variables. It only assigns the out-vars to 0.
		\item $\outvars_0 = \{ x \mapsto x_0, y \mapsto y_0\}$
		\item $\auxvars_0 = \emptyset$
		\item $\varphi_0: (x_0 = 0 \land y_0 = 0)$
		\item $\widehat{\varphi_0}: (c_x' = 0 \land c_y' = 0)$ with $c_x'$ and $c_y'$ being the primed constants of $x$ and $y$.
	\end{itemize}
	
	
	\subsection*{Example 2:}
	Assume we are given a program that is represented by CFG $G_1$ \\ $G_1 = (\{ \ell_1, \ell_2 \}, \{ (\ell_1, \ell_2)\}, \ell_1, \emptyset, ((\ell_1, \ell_2) 
	\mapsto \psi_1))$

		\begin{minipage}{.3\textwidth}
			\centering
			\begin{align*}
				&\texttt{x, y : int}; \\
				&\texttt{x := x + 1}; \\
				&\texttt{y := y + 1;}
			\end{align*}

			
			\captionof{figure}{Program $P_1$}
			\label{fig:square}
		\end{minipage}%
		\hfill
		\begin{minipage}{.6\textwidth}
			\centering
		\begin{tikzpicture}[%
					->,
					>=stealth', shorten >=1pt, auto,
					node distance=3cm, scale=1, 
					transform shape, align=center,    
					smallnode/.style={inner sep=1.4}
					]
					\node[state](1){$\ell_1$};
					
					\node[state] (2) [below of=1] {$\ell_2$};
					
					\path (1) edge node {%
						$
						\psi_1 := \left\{
						\begin{array}{lcl}
						\invars       & = & \{x \mapsto x_{1}, y \mapsto y_{1} \} \\
						\outvars      & = & \{ x \mapsto x_{2} , y \mapsto y_{2} \} \\
						\auxvars      & = & \emptyset \\
						\varphi       & = & x_{2} = x_{1} + 1 \; \land \; y_{2} = x_{2} + y_{1} \\
						\widehat{\varphi} & = & c_{x}' = c_x + 1 \;\land\; c_{y}' = c_{x}' + c_y \\
						\end{array}
						\right.
						$ %
					} (2)
					;
					
					
					);
					\end{tikzpicture}
			\captionof{figure}{$G_1$}
			\label{fig:rect}
		\end{minipage}%
\bigskip

	Where $\psi = (\invars_1, \outvars_1, \auxvars_1, \varphi_1, \widehat{\varphi}_1)$ is a transformula consisting of: 
	\begin{itemize}
		\item $\invars_1 = \{x \mapsto x_1, y \mapsto y_1 \}$.
		\item $\outvars_1 = \{ x \mapsto x_2, y \mapsto y_2 \}$
		\item $\auxvars_1 = \emptyset $
		\item $	\varphi = ( x_{2} = x_{1} + 1 \; \land \; y_{2} = x_{2} + y_{1} ) $
		\item $\widehat{\varphi} = ( c_{x}' = c_x + 1 \;\land\; c_{y}' = c_{x}' + c_y ) $ with $c_x, c_x'$ and $c_y, c_y'$ being the unprimed and primed constants of $x$ and $y$.
	\end{itemize}
    
	
	\subsection*{Example 3:}
	If we take both previous example and combine them to one CFG, we get \\ $CFG_{0+1} = (\{ \ell_0, \ell_1, \ell_2\}, \{ (\ell_0, \ell_1), (\ell_1, \ell_2)\}, \ell_0, \emptyset, ((\ell_0, \ell_1) \mapsto \psi_0, (\ell_1, \ell_2) \mapsto \psi_1))$.

			\begin{minipage}{.3\textwidth}
		\centering
		\begin{align*}
			&\texttt{x, y : int}; \\
			&\texttt{x := 0}; \\
			&\texttt{y := 0;} \\
			&\texttt{x := x + 1}; \\
			&\texttt{y := y + 1;}
		\end{align*}

		
		
		\captionof{figure}{Program $P_{0+1}$}
		\label{fig:square}
	\end{minipage}%
	\hfill
	\begin{minipage}{.6\textwidth}
		\centering
		\begin{tikzpicture}[%
					->,
					>=stealth', shorten >=1pt, auto,
					node distance=3cm, scale=1, 
					transform shape, align=center,    
					smallnode/.style={inner sep=1.4}
					]
					\node[state](1){$\ell_0$};
					
					\node[state] (2) [below of=1] {$\ell_1$};
					
					\node[state] (3) [below of=2] {$\ell_2$};
					
					
					\path (1) edge node {%
						$
						\psi_0 := \left\{
						\begin{array}{lcl}
						\invars       & = & \emptyset \\
						\outvars      & = & \{ x \mapsto x_{0} , y \mapsto y_{0} \} \\
						\auxvars      & = & \emptyset \\
						\varphi       & = & x_{0} = 0 \; \land \; y_{0} = 0 \\
						\widehat{\varphi} & = & c_{x}' = 0 \;\land\; c_{y}' = 0 \\
						\end{array}
						\right.
						$ %
					} (2)
					;
					\path (2) edge node {%
						$
						\psi_1 := \left\{
						\begin{array}{lcl}
						\invars       & = & \{x \mapsto x_{1}, y \mapsto y_{1} \} \\
						\outvars      & = & \{ x \mapsto x_{2} , y \mapsto y_{2} \} \\
						\auxvars      & = & \emptyset \\
						\varphi       & = & x_{2} = x_{1} + 1 \; \land \; y_{2} = x_{2} + y_{1} \\
						\widehat{\varphi} & = & c_{x}' = c_x + 1 \;\land\; c_{y}' = c_{x}' + c_y \\
						\end{array}
						\right.
						$ %
					} (3)
					;
					\end{tikzpicture}
		\captionof{figure}{$G_{0+1}$}
		\label{fig:rect}
	\end{minipage}%


	We see $CFG_{0+1}$ contains two TFs. We can get a single formula describing the whole program by concatenating those two formulas:
	$\psi_2 = \psi_0 \circ \psi_1$ \\
	
	\begin{mydef}
		A concatenation of two Transformulas 
		\begin{equation*}
		\psi_{1 \circ 2} = \psi_1 \circ \psi_2 = (\invars_{1 \circ 2}, \outvars_{1 \circ 2}, \auxvars_{1 \circ 2}, \varphi_{1 \circ 2}, \widehat{\varphi}_{1 \circ 2})
		\end{equation*}  yields one Transformula describing the behaviour of both of them. With
		\begin{itemize}
			\item $\invars_{1 \circ 2} = \invars_1$
			\item For $\outvars_{1 \circ 2}$ we have to distinguish three cases cases: 
			\jw{is the case where var is not changed in either TF important?}
			\begin{itemize}
				
				\item[I:] $(x \mapsto x_i) \in Out_1$ and $x  \not\in entries(Out_2)$, meaning program variable is solely modified in $\psi_1$. In that case the out variable of the concatenation is the same as the out variable of $\psi_1: $ $\outvars_{1 \circ 2} \cup (x \mapsto x_i)$ 
				\item[II:] $(x \mapsto x_j) \in Out_2$ and $x  \not\in entries(Out_1)$, meaning program variable is solely modified in $\psi_2$. In that case the out variable of the concatenation is the same as the out variable of $\psi_2: $ $\outvars_{1 \circ 2} \cup (x \mapsto x_j)$ 
				\item[III:] $x \in entries(Out_1)$ and $x \in entries(Out_2)$, meaning program variable $x$ is modified in both transformulas which can create a term variable naming conflict. 
				In this case $\outvars_{1 \circ 2} \cup (x \mapsto \widehat{x_j})$ where $\widehat{x_j}$ is a fresh term variable that has not been used before.
				
			\end{itemize}

			\item $\auxvars_{1 \circ 2} = \{ \widehat{v_i} \ |\ v_i \in \auxvars_1 \cup \auxvars_2 \cup range(\invars_2) \text{ where } \widehat{v_i} \text{ is a fresh variable of } v_i \}$
			\item $\varphi_{1 \circ 2}$ = $\varphi_1[x_i / x_j, v_i / \widehat{v_i} ] \land \varphi_2[v_j / \widehat{v_j}, x_j / \widehat{x_j}]$, where
			 \begin{itemize}
				\item $\varphi_1[x_i / x_j, v_i / \widehat{v_i} ] $ is $\varphi_1$ where we substitute every program variable mapping $(x \mapsto x_i) \in \outvars_1$ with $(x \mapsto x_j) \in \invars_2$ and each $v_i \in \auxvars_1$ with a fresh variable $\widehat{v_i}$.
				\item  $\varphi_2[v_j / \widehat{v_j}, x_j / \widehat{x_j}]$ is $\varphi_2$ where we substitute each $v_j \in \auxvars_2$ with a fresh variable $\widehat{v_j}$ and each mapping $(x \mapsto x_j) \in \outvars_2$, that fulfills out-variable case $III$, with $(x \mapsto \widehat{x_j})$.
			\end{itemize} 
			
			%is the conjunction of $\varphi_1$ in which we replace every $(x, x_i) \in \outvars_0$ with $(PV, TV_2) \in \invars_2$ and each $v_1 \in \auxvars_1$ with a fresh variable $v_1'$ %and $\varphi_2$ in which we too replace each $v_2 \ in \auxvars_2$ with a fresh variable $v_2'$ and we replace each $(PV, TV_2) \in \outvars_2$ with a fresh variable $TV_2'$.
			\item $\widehat{\varphi}_{1 \circ 2}$ is the closed formula of $\varphi_{1 \circ 2}$ where every in-variable is replaced by the unprimed constant of the corresponding program variable and every out-variable is replaced by the primed constant. For every every $v \in \auxvars_{1 \circ 2}$ we introduce a fresh constant.
		\end{itemize}
	\end{mydef}

	\smallskip
	Using this definition we get $\psi_2 = \psi_0 \circ \psi_1$ with
	\begin{itemize}
		\item $\invars_2 = \invars_0 = \emptyset$
		\item $\outvars_2 = \{ x \mapsto x_3, y \mapsto y_3 \}$ \\ where $x_3$ and $y_3$ are new term variables because $x$ and $y$ are changed in both $\psi_0$ and $\psi_1$.
		\item $\auxvars_2 = \{x_1, y_1 \} $
		\item $\varphi_2 = (x_1 = 0 \land y_1 = 0 \land x_3 = x_1 + 1 \land y_3 = x_3 + y_1)$
		\item $\widehat{\varphi_2} = (c_1 = 0 \land c_2 = 0 \land c_x' = c_1 + 1 \land c'_y = c_x' + c_2)$ \\ We generated new constants for each aux-var: \\
		$x_1 \mapsto c_1, y_1 \mapsto c_2$
	\end{itemize}
	With this concatenation we can reduce $CFG_{0+1}$ from three locations and two TFs to two locations and only one TF $\psi_2$: \\
	
	\begin{figure}[H]
		\centering
		\begin{tikzpicture}[%
		->,
		>=stealth', shorten >=1pt, auto,
		node distance=3cm, scale=1, 
		transform shape, align=center,    
		smallnode/.style={inner sep=1.4}
		]
		\node[state](1){$\ell_0$};
		
		\node[state] (2) [below of=1] {$\ell_2$};
		
		\path (1) edge node {%
			$
			\psi_2 := \left\{
			\begin{array}{lcl}
			\invars       & = & \emptyset \\
			\outvars      & = & \{ x \mapsto x_3, y \mapsto y_3 \} \\
			\auxvars      & = &  \{x_1, y_1 \} \\
			\varphi       & = & (x_1 = 0 \land y_1 = 0 \land x_3 = x_1 + 1 \land y_3 = x_3 + y_1) \\
			\widehat{\varphi} & = & (c_1 = 0 \land c_2 = 0 \land c_x' = c_1 + 1 \land c'_y = c_x' + c_2) \\
			\end{array}
			\right.
			$ %
		} (2)
		;
		
		
		);
		\end{tikzpicture}
		\caption{Reduced CFG $G_{0+1}$.}
	\end{figure}

	\subsection{Interprocedual Control Flow Graphs}
	
	We want to be able to handle programs that consist of procedures that call other procedures, so called interprocedual programs, for that we need to modify our definitions from the previous chapter.
	
	\begin{mydef}
		An interprocedual control flow graph (ICFG) is a tuple \\$IG = (Loc, \Delta, \ell_{init}, \ell_E, st, proc)$ where $Loc$, $\Delta$, $\ell_{init}$, $\ell_E$, and st have the same definition as in regular CFGs. $proc$ is a set of different procedures in the program. 
		%where transitions $(\ell, \ell' \in \Delta)$ are not only internal transitions but also call and return transitions. An ICFG can contain more than one procedure and with that being %able to represent programs that have more than one procedure as well.
	\end{mydef}
	What is special about transitions in ICFGs is that they can lead to different procedures:
	\begin{mydef} Assume we are given an ICFG $IG = (Loc, \Delta, \ell_{init}, \ell_E, st, proc)$, we find three distinct classes of program transitions in $\Delta$:
		\begin{itemize}
			\item Internal transitions: An internal transition $(\ell, \ell') \in \Delta$ is a program transition where both $\ell$ and $\ell'$ are part of the same procedure. $st(\ell, \ell')$ is a transformula describing the change in variables.
			
			\item Call transitions:  A call transition leads the control flow from one procedure to another. We define that each procedure $p \in proc$ has a unique entry location $\ell^{entry}_p$. A transition $(\ell, \ell') \in \Delta$ is called a call transition, if $\ell$ is a location in procedure $p$ and $\ell'$ is the entry location of another procedure $q \in proc$. \\ $st(\ell, \ell')$ consists of three transformulas, $\psi_{old}, \psi_{global}$ and $\psi_{local}$: 
			\begin{itemize}
				\item$\psi_{old}$: Assuming we have global variables $g_0, ..., g_n$ that are modified by the called procedure $q$. $\psi_{old}$ is a conjunction of assignments of each of those $g_i$ to a fresh variable $old_{i}$. This saves the values of the global variables before executing the $q$. 
				\item $\psi_{global}$ is a transformula describing the how $q$ changes the global variables.
				\item $\psi_{local}$ is a transfomula describing how the local variables, the variables that are only used in the scope of $q$, are modified.
			\end{itemize}
			
			\item Return transitions: A return transition leads the control flow from one called procedure back to the original caller procedure. We define that each procedure $p \in proc$ has one unique exit location $\ell^{exit}_p$. A transition $(\ell, \ell') \in \Delta$ is called a return transition, if $\ell$ is the exit location $\ell_q^{exit}$ of procedure $q \in proc$ and $\ell'$ is a location of caller procedure $p$. There is a map that maps each return to its corresponding call. \\
			$st(\ell, \ell')$ consists of two transformulas, $\psi_{ass}$ and $\psi_{local}$: 
			\begin{itemize}
				\item $\psi_{ass}$ is a transformula describing how variables that are explicitly mentioned in the call of the corresponding procedure are updated after the return to the calling procedure. For example how $i$ is updated after the call $i := foo()$, where $foo$ changes variable $i$.
				\item $\psi_{local}$ is the same transformula as the $\psi_{local}$ of the corresponding call statement, that describe how the local variables of $q$ are modified.
			\end{itemize}
		\end{itemize}
	\end{mydef}

	\jw{If we have those TFs for procedures we do not have to look at the internal transitions of the procedure itself? \\ Can we concatenate these formulas like above? \\ Aren't these formulas acting like summaries of the procedure? \\ How are these formulas used in the context of the calling procedure? \\
	Do we need $\psi_{local}$ at all, we are not interested in local variable changes in a called procedure?}
	
	\jw{ToDo ICFG elaborate ICFG example}
	
	\pagebreak
		
	\subsection{Interpolation}
	Interpolants are used as a way of covering a more general state space. There are multiple ways of finding interpolants for given formulas.
	In the following we will introduce two techniques: Craig interpolation and Selfless interpolation. 
	\jw{citation needed}
	
	\begin{mydef}
		Let $(A, B)$ be a pair of formulas such that $A \land B$ is unsatisfiable. A Craig interpolant $I$ for $(A, B)$ is a formula fulfilling the following characteristics:
		\begin{itemize}
			\item $A \Rightarrow I$
			\item $I \land B$ is unsatisfiable
			\item $I$ consists only of variables found in $A \cap B$
		\end{itemize}
	\end{mydef}

	Next to Craig interpolation, there are other kinds of getting interpolants:
	\begin{mydef}
		\jw{Introduce Selfless interpolation}
	\end{mydef}
	\pagebreak
	
	%-------------------------------------------------%
	\section{PDR in Ultimate}
	%-------------------------------------------------%
	In this section we swiftly introduce our PDR implementation, describe how it works, and introduce the problems we solved in this project.
	
	\subsection{PDR for Software}
	PDR was first devised as a means of hardware verification, however in my 2018 Bachelor's Thesis we divised a way of using it on software, this approach was based on the technique described by Lange et al. \cite{DBLP:conf/fmcad/0001NN15}
	Instead of unrolling the transition relation of a given program's CFG like other verification techniques PDR checks only local transitions in a backwards-search like manner.
	\smallskip
	To check correctness of a program PDR uses an array of frames for each program location $\ell \in Loc$. 
	\begin{mydef}
		A frame $F_{i,\ell}$ is a predicate mapped to a program location $\ell$ and an iteration of PDR, called level, $i$.
		Every program location $\ell \in Loc$ is assigned its own array of frames. These are used to overapproximate reachable states from the corresponding location.
	\end{mydef}
	Furthermore to check reachability of an error state PDR maintains a stack of so called proof-obligations.
	\begin{mydef}
		A proof-obligation is a triple po = $(t, \ell, i)$ with a predicate $t$, a program location $\ell$, and an integer, called level, $i$
		As the name suggests proof-obligations have to be proven, if it is possible to generate a proof-obligation on level $i = 0$ we can say that the program is unsafe.
	\end{mydef}
	PDR is initialized by generating the first frame for each program location as $\{ false \}$ except the initial location which has frame $\{ true \}$. If there is a transition $(\ell, \ell_E)$ into an error node PDR generates its first proof-obligation $(t, \ell, 1)$ $t$ being the transformula $st(\ell, \ell_E)$.
	In each new iteration PDR adds a new frame to the program locations. This new frame is $\{true\}$, further
	an iteration of PDR is divided into two phases, the blocking-phase, and the propagation-phase.
	
	\bigskip
	
	In the blocking phase we try to clear the proof-obligation stack by generating queries to an SMT-solver.
	If the query is unsatisfiable, we can block the proof-obligation, meaning that the successors of the given transformula are not reachable.
	If such a query is satisfiable we know that the corresponding proof-obligation cannot be proven unreachable yet. Given proof-obligation  $po = (t, \ell, i)$ we generate a new proof-obligation $(st(\ell_{pre}, \ell), \ell_{pre}, i-1) $ for each predecessor location $\ell_{pre}$ of $\ell$.
	
	\bigskip
	
	If the proof-obligation stack could be emptied, PDR enters the propagation-phase where it scouts through the frames of the program locations to find a fixpoint. \\
	\begin{mydef}
		A fixpoint in the frames is a level $i$ where $F_{i, \ell} = F_{i-1, \ell}$ for every location $\ell \in Loc$. If there is such a fixpoint then the given program is safe.
	\end{mydef}
	If there is neither a proof-obligation on level 0 or a fixpoint in the frames, PDR starts a new iteration.

	\subsection{SMT-queries}
	As mentioned before, PDR constructs queries to an SMT-solver in the blocking-phase, those are conjunctions of three predicates. Given proof-obligation $po = (t, \ell, i)$ the algorithm checks for each predecessor location of $\ell$ $\ell_{pre}$ if the formula:
	\begin{equation*}
	F_{i - 1, \ell_{pre}} \land T_{\ell_{pre} \rightarrow \ell} \land t'
	\end{equation*}
	is satisfiable. Here $F_{i-1, \ell_{pre}}$ is the frame of a previous iteration, $T_{\ell_{pre} \rightarrow \ell}$ is the transformula $st(\ell_{pre}, \ell)$ and $t'$ is the primed proof-obligation.
	Our implementation treats the frame as a precondition, the proof-obligation as a post condition and the transformula as a possible transition between. Now to check the satisfiability we use the closed formula of the precondition
	
	\section{Using Interpolants}
	Adding the negated proof-obligation to the frames works well in most cases. Consider program $\mathcal{A}$ in Figure 3.4. The initial proof-obligation on level $i$ is $(x = 1, \ell_1, i)$, because $\ell_1$ has two predecessors we have to check:
	\begin{equation}
	F_{\ell_1, i - 1} \land x' = x + 1 \land x' = 1
	\end{equation}
	\begin{equation}
	F_{\ell_0, i - 1} \land x' = 2 \land x' = 1
	\end{equation}
	for satisfiability. \\
	Formula (3.1) is satisfiable until we get a proof-obligation on level 1, because frame $F_{\ell_1, 0}$ is always false. \\
	Formula (3.2) is always unsatisfiable, in each level we add $x \neq 1$ to $\ell_1$'s frames. That formula however is not strong enough to block the chain of satisfiable obligations of (3.1) in the next level, which is inefficient.
	
	\section{Evaluation}
	Run the benchmarks again and compare them to the ones from last year, where we will see (hopefully) a speedup.
	
	\pagebreak
	
\addcontentsline{toc}{chapter}{Bibliography}
\bibliographystyle{plain}
\bibliography{bib}

	
\end{document}