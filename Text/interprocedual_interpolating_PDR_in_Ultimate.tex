\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage{xspace}
\usepackage{tabu}
\usepackage[%
  hyperindex,%
  plainpages=false,%
  pdfusetitle]{hyperref}
\usepackage[all]{hypcap}
\usepackage{cite}
\usepackage{booktabs}
\usepackage{url}
\usepackage{listings}
\usepackage{enumitem}
\usepackage{amsthm}
\usepackage{amsmath}

\usepackage[%disable,%
  colorinlistoftodos,%
  color=cyan!50!white,%
  bordercolor=cyan!50!black]{todonotes}

%%%%%%%%%%%% Colors 
%% a somewhat friendly scheme for 5 different colors 
\definecolor{g1}		{RGB}{215,25,28} % a kind of red
\definecolor{g2}		{RGB}{253,174,97} % a kind of orange
\definecolor{g3}		{RGB}{255,255,191} % a kind of yellow
\definecolor{g4}		{RGB}{171,217,233} % a kind of light blue 
\definecolor{g5}		{RGB}{44,123,182} % a kind of dark blue 

\definecolor{gr1}		{RGB}{250, 250, 250}
\definecolor{gr2}		{RGB}{229, 229, 229} % some grey

% color of interpolants
\definecolor{grey}{RGB}{200,200,200}

%color for pictures
\colorlet{outlineblue}		{g5}
\colorlet{fillblue}			{g4}
\colorlet{darkback}			{gr2}
\colorlet{lightback}		{gr1}
\colorlet{stmtcolor}		{gr2} %default statement color
\colorlet{subgraphcolor}	{g3} %default statement color


%%%%%%%%%%%% Setup
\newtheorem{name}{Printed output}
\newtheorem{mydef}{Definition}

\hypersetup{
colorlinks=true,        % false: boxed links; true: colored links
linkcolor=g1,        % color of internal links
citecolor=g1,        % color of links to bibliography
filecolor=g1,        % color of file links
urlcolor=g1          % color of external links
}


\lstdefinestyle{boogie}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  xleftmargin=\parindent,
  showstringspaces=false,
  basicstyle=\footnotesize\ttfamily,
  numbers=left,
  xleftmargin=.6cm
}

\lstset{escapechar=@,style=boogie}

%%%%%%%%%%%% Comments
\newif\iffinal
%\finaltrue % comment out to remove comments 
 
\iffinal
\newcommand\mycom[1]{}
\else
\newcommand\mycom[1]{#1}
\overfullrule=1mm
\fi

\newcommand{\jw}[1]{\mycom{\todo[color=blue!40,inline]{\small JW: #1}}}
\newcommand{\jwl}[1]{\mycom{\todo[color=blue!40,inline,caption={Beschreibung},nolist]{\small #1}}}
\newcommand{\dd}[1]{\mycom{\todo[color=orange!40,inline]{\small DD: #1}}}
\newcommand{\ddl}[1]{\mycom{\todo[color=orange!40,inline,caption={Beschreibung},nolist]{\small #1}}}

\newcommand{\all}[1]{\mycom{\todo[color=green!40,inline]{\small #1}}}
\newcommand{\meta}[1]{\mycom{\todo[color=blue!10,inline,caption={Beschreibung},nolist]{\setlist{nolistsep}\small #1}}}
\newcommand{\xxx}{\mycom{\stfootcol{Placeholder}{blue!20}\xspace}}
\newcommand{\cn}{\mycom{\stfootcol{Cite}{blue!20}\xspace}}


%%%%%%%%%%%% Actual content
\begin{document}
	\newcommand{\HorizontalLine}{\rule{\linewidth}{0.3mm}}
	
	\title{ \HorizontalLine \\ \textbf{Interprocedual and Interpolating \\ Property Directed Reachability in \textsc{Ultimate}} \HorizontalLine}
	

	
	\author{Jonas Werner \\ Supervised By: Dr. Daniel Dietsch}


	
	\date{} 
	
	\maketitle
	
	\begin{abstract}
	In a previous project we implemented a library using PDR for software verification in the program analysis framework ULTIMATE. However \jw{...}
	\end{abstract}
	
	
	%-------------------------------------------------%
	\section{Introduction}
	%-------------------------------------------------%
	
	Property Directed Reachability (PDR) was first devised as a hardware verification paradigm by Aaron Bradley \cite{DBLP:conf/vmcai/Bradley11}. It however showed potential as a software verification method as well.
	In the course of my 2018 Bachelor's Thesis we devised a method of using Property Directed Reachability on software in the software analysis framework \textsc{Ultimate} \cite{Zitat02}. \\
	Our approach was based on the technique described by Lange et al \cite{DBLP:conf/date/WelpK13}. \\ The implementation worked however solely on intraprocedual programs, meaning that if we encountered a call to another procedure, it would no longer continue the verification process. \\
	Furthermore our implementation did not make use of interpolants which broaden the state space covered by blocked proof-obligations. \\
	This project aims at expanding PDR with both interprocedual analysis capabilities and usage of interpolants. \jw{\textbf{Both kinds of interpolants: Craig and selfless (citation needed)}} \par
    This paper is structured as follows, firstly we will give some background definition of interprocedual program analysis, and interpolants, then we will describe our changes made to our PDR library.
	
	%-------------------------------------------------%
	\section{Background}
	%-------------------------------------------------%
	In this section we will give preliminary definitions on what interprocedual programs are and what interpolants we use.
	
    
    \newcommand{\tf}{\ensuremath{\varphi}\xspace}
    \newcommand{\ctf}{\ensuremath{\hat{\varphi}}\xspace}
    \newcommand{\invars}{\ensuremath{In}\xspace}
    \newcommand{\outvars}{\ensuremath{Out}\xspace}
    \newcommand{\auxvars}{\ensuremath{Aux}\xspace}
	
	\subsection{Interprocedual Control Flow Graphs}	
	Given a program we need a way to model its control flow to check whether given error states can be reachable or not, for that we introduce control flow graphs.
    \dd{complete transformula def}
    \begin{mydef}
        A transformula (TF) is a tuple $TF = (\invars, \outvars, \auxvars, \tf, \ctf)$ with 
        \begin{itemize}
          \item $\invars : PV \rightarrow TV$ is a mapping from program variables to unprimed termvariables called the in-variables, 
          \item $\outvars : PV \rightarrow TV$ is a mapping from program variables to primed termvariables called the out-variables, 
          \item $\auxvars \subseteq TV$ is a set of termvariables that only exist in the context of this transformula called the aux-variables, 
          \item $\tf$ is a formula over termvariables from $\invars$, $\outvars$, and $\auxvars$ (the actual transformula), and
          \item $\ctf$ is the closed formula over termvariables from $\invars$, $\outvars$, and $\auxvars$, i.e., every variable in \tf is replaced by a constant. 
        \end{itemize}
        \dd{Explain that in \ctf each invar is replaced by \emph{the} constant of the corresponding program variable, ...}
    \end{mydef}
    %

	\begin{mydef}
		A control flow graph (CFG) is a directed graph G = ($Loc$, $\Delta$, $\ell_{init}$, $\ell_E$, st) of a program where
		\begin{itemize}
			\item  Loc is a set of program locations
			\item $\Delta$ is a set of internal program transitions consisting of tuples $(\ell, \ell')$, $\ell, \ell' \in Loc$
			\item $\ell_{init} \in Loc$ is the initial location
			\item $\ell_E \in Loc$ an error location
			\item st: $\Delta \rightarrow TF$ is a labeling function that assigns each transition in $\Delta$ a transformula.
		\end{itemize}
	\end{mydef} \noindent
	 %
	For example, we are given program P: \jw{\textbf{ToDo example}}
	\bigskip\bigskip\bigskip\noindent
	Because we want to deal with programs that consist of more than one procedure, we first need to define three classes of program transitions.
	
	\begin{mydef} In interprocedual programs we find three distinct classes of program transitions:
		\begin{itemize}
			\item Internal transitions: An internal transition $(\ell, \ell') \in \Delta$ is a program transition where both $\ell$ and $\ell'$ are part of the same procedure. 
			
			\item Call transitions:  A call transition leads the control flow from one procedure to another. We define that each procedure p in a program has a unique entry location $\ell^{entry}_p$. A transition $(\ell, \ell') \in \Delta$ is called a call transition, if $\ell$ is a location in procedure $p$ and $\ell'$ is the entry location of another procedure $q$.
			
			\item Return transitions: A return transition leads the control flow from one called procedure back to the original caller procedure. We define that each procedure $p$ has one unique exit location $\ell^{exit}_p$. A transition $(\ell, \ell') \in \Delta$ is called a return transition, if $\ell$ is the exit location $\ell_q^{exit}$ of procedure $q$ and $\ell'$ is a location of caller procedure $p$. Each return has a corresponding call.
		\end{itemize}
	\end{mydef}
	 \bigskip\noindent
	Considering these program transitions we need to modify our definition of a CFG to get Interprocedual Control Flow Graphs. As CFGs only deal with internal transitions.
	\begin{mydef}
		An interprocedual control flow graph (ICFG) is a CFG G = ($Loc$, $\Delta$, $\ell_{init}$, $\ell_E$, st) where transitions $(\ell, \ell' \in \Delta$ are not only internal transitions but also call and return transitions. An ICFG can contain more than one procedure and with that being able to represent programs that have more than one procedure as well.
	\end{mydef}
	
	\jw{\textbf{@ToDo extend example by procedure call}} 
	We see that foo calls bar during its run. Our current definition of CFGs do not support those calls yet, we need to expand it to deal with programs containing multiple procedures.
	
	
	\pagebreak
		
	\subsection{Interpolation}
	Interpolants are used as a way of covering a more general state space. There are multiple ways of finding interpolants for given formulas.
	In the following we will introduce two techniques: Craig interpolation and Selfless interpolation. 
	\jw{citation needed}
	
	\begin{mydef}
		Let $(A, B)$ be a pair of formulas such that $A \land B$ is unsatisfiable. A Craig interpolant $I$ for $(A, B)$ is a formula fulfilling the following characteristics:
		\begin{itemize}
			\item $A \Rightarrow I$
			\item $I \land B$ is unsatisfiable
			\item $I$ consists only of variables found in $A \cap B$
		\end{itemize}
	\end{mydef}

	Next to Craig interpolation, there are other kinds of getting interpolants:
	\begin{mydef}
		\jw{Introduce Selfless interpolation}
	\end{mydef}
	\pagebreak
	
	%-------------------------------------------------%
	\section{PDR in Ultimate}
	%-------------------------------------------------%
	In this section we swiftly introduce our PDR implementation, describe how it works, and introduce the problems we solved in this project.
	
	\subsection{PDR for Software}
	PDR was first devised as a means of hardware verification, however in my 2018 Bachelor's Thesis we divised a way of using it on software, this approach was based on the technique described by Lange et al. \jw{Citation needed}
	Instead of unrolling the transition relation of a given program's CFG like other verification techniques PDR checks only local transitions in a backwards-search like manner.
	\smallskip
	To check correctness of a program PDR uses an array of frames for each program location $\ell \in Loc$. 
	\begin{mydef}
		A frame $F_{i,\ell}$ is a predicate mapped to a program location $\ell$ and an iteration of PDR, called level, $i$.
		Every program location $\ell \in Loc$ is assigned its own array of frames. These are used to overapproximate reachable states from the corresponding location.
	\end{mydef}
	Furthermore to check reachability of an error state PDR maintains a stack of so called proof-obligations.
	\begin{mydef}
		A proof-obligation is a triple po = $(t, \ell, i)$ with a predicate $t$, a program location $\ell$, and an integer, called level, $i$
		As the name suggests proof-obligations have to be proven, if it is possible to generate a proof-obligation on level $i = 0$ we can say that the program is unsafe.
	\end{mydef}
	PDR is initialized by generating the first frame for each program location as $\{ false \}$ except the initial location which has frame $\{ true \}$. If there is a transition $(\ell, \ell_E)$ into an error node PDR generates its first proof-obligation $(t, \ell, 1)$ $t$ being the transformula $st(\ell, \ell_E)$.
	In each new iteration PDR adds a new frame to the program locations. This new frame is $\{true\}$, further
	an iteration of PDR is divided into two phases, the blocking-phase, and the propagation-phase.
	
	\bigskip
	
	In the blocking phase we try to clear the proof-obligation stack, we do that by generating queries to an SMT-solver.
	If the query is unsatisfiable, we can block the proof-obligation, meaning that the successors of the given transformula are not reachable.
	If such a query is satisfiable we know that the corresponding proof-obligation cannot be blocked yet. We generate a new proof-obligation ...
	
	\bigskip
	
	If the proof-obligation stack could be emptied, PDR enters the propagation-phase where it scouts through the frames of the program locations to find a fixpoint. \\
	\begin{mydef}
		A fixpoint in the frames is a level $i$ where $F_{i, \ell} = F_{i-1, \ell}$ for every location $\ell \in Loc$. If there is such a fixpoint then the given program is safe.
	\end{mydef}
	If there is neither a proof-obligation on level 0 or a fixpoint in the frames, PDR starts a new iteration.

	\subsection{SMT-queries}
	As mentioned before, PDR constructs queries to an SMT-solver in the blocking-phase, those are conjunctions of three predicates. Given proof-obligation $po = (t, \ell, i)$ \\
	Here the algorithm takes proof-obligation $(t, \ell, i)$ checks for each predecessor location $\ell_{pre}$ if the formula:
	\begin{equation*}
	F_{i - 1, \ell_{pre}} \land T_{\ell_{pre} \rightarrow \ell} \land t'
	\end{equation*}
	is satisfiable. \\
	\jw{DO THE RENAMING STUFF}
	
	
	\section{Using Interpolants}
	How we make use of the interpolants, meaning showing that we strengthen the frames with an interpolant to cover more predecessor states. Example maybe
	
	\section{Evaluation}
	Run the benchmarks again and compare them to the ones from last year, where we will see (hopefully) a speedup.
	
	\pagebreak
	
\addcontentsline{toc}{chapter}{Bibliography}
\bibliographystyle{plain}
\bibliography{bib}

	
\end{document}