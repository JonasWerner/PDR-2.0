\documentclass{article}
\usepackage{amsthm}
\usepackage{url}
\newtheorem{name}{Printed output}
\newtheorem{mydef}{Definition}


\begin{document}
	\newcommand{\HorizontalLine}{\rule{\linewidth}{0.3mm}}
	
	\title{ \HorizontalLine \\ \textbf{Interprocedual and Interpolating \\ Property Directed Reachability in \textsc{Ultimate}} \HorizontalLine}
	

	
	\author{Jonas Werner \\ Supervised By: Dr. Daniel Dietsch}


	
	\date{} 
	
	\maketitle
	
	\begin{abstract}
	In a previous project we implemented a library using PDR for software verification in the program analysis framework ULTIMATE. However...
	\end{abstract}
	
	
	%-------------------------------------------------%
	\section{Introduction}
	%-------------------------------------------------%
	
	Property Directed Reachability (PDR) was first devised as a hardware verification paradigm by Aaron Bradley \cite{DBLP:conf/vmcai/Bradley11}. It however showed potential as a software verification method as well.
	In the course of my 2018 Bachelor's Thesis we devised a method of using Property Directed Reachability on software in the software analysis framework \textsc{Ultimate} \cite{Zitat02}. \\
	Our approach was based on the technique described by Lange et al \cite{DBLP:conf/date/WelpK13}. \\ The implementation worked however solely on intraprocedual programs, meaning that if we encountered a call to another procedure, it would no longer continue the verification process. \\
	Furthermore our implementation did not make use of interpolants which broaden the state space covered by blocked proof-obligations. \\
	This project aims at expanding PDR with both interprocedual analysis capabilities and usage of interpolants. (@ToDo \textbf{Both kinds of interpolants: Craig and selfless (citation needed)}) \par
    This paper is structured as follows, firstly we will give some background definition of interprocedual program analysis, and interpolants, then we will describe our changes made to our PDR library.
	
	%-------------------------------------------------%
	\section{Background}
	%-------------------------------------------------%
	In this section we will give preliminary definitions on what interprocedual programs are and what interpolants we use.
	
	
	\subsection{Interprocedual Control Flow Graphs}	
	Given a program we need a way to model its control flow to check whether given error states can be reachable or not, for that we introduce control flow graphs.
	
	\begin{mydef}
		A control flow graph (CFG) is a directed graph G = ($Loc$, $\Delta$, $\ell_{init}$, $\ell_E$, st) of a program where
		\begin{itemize}
			\item  Loc is a set of program locations
			\item $\Delta$ is a transition relation that consists of tuples $(\ell, \ell')$, where $\ell, \ell' \in Loc$
			\item $\ell_{init} \in Loc$ is the initial location
			\item $\ell_E \in Loc$ an error location
			\item st: $\Delta \rightarrow Stmt$ is a labeling function that assigns each transition in $\Delta$ a statement s which is either an assignment, an assume, or a havoc statement.
		\end{itemize}

	\end{mydef} \noindent
	For example, we are given program P: \textbf{ToDo example}
	\\ \\
	

	Most programs feature calls to other functions: \\
	\textbf{@ToDo extend example by procedure call} \\
	We see that foo calls bar during its run. Our current definition of CFGs do not support those calls yet, we need to expand it to deal with programs containing multiple procedures.
	
	
	
	\begin{mydef}
		An interprocedual control flow graph (ICFG) is a CFG G = ($Loc$, $\Delta$, $\ell_{init}$, $\ell_E$, st) where we modify the labeling function st by adding two new program statements.
		$call$ and $return$.
		\begin{itemize}
			\item A call statement leads the control flow from one procedure to another. We define that each procedure p in a program has a unique entry location $\ell^{entry}_p$.
			A transition $(\ell, \ell') \in \Delta$ is called a call transition, if $\ell$ is a location in procedure $p$ and $\ell'$ is the entry location of another procedure $q$, with st$(\ell, \ell')$ being a call statement.
			
			\item A return statement leads the control flow from one called procedure back to the original caller procedure. We define that each procedure $p$ has one unique exit location $\ell^{exit}_p$. A transition $(\ell, \ell') \in \Delta$ is called a return transition, if $\ell$ is the exit location $\ell_q^{exit}$ of procedure $q$ and $\ell'$ is a location of caller procedure $p$, with st$(\ell, \ell')$ being a return statement.
		\end{itemize}
	Each return has a corresponding call.
	\end{mydef}
	
	
	\pagebreak
		
	\subsection{Interpolation}
	Given two formulas, we can calculate an interpolant.... todo
	
	\begin{mydef}
		Let $(A, B)$ be a pair of formulae such that $A \land B$ is unsatisfiable. An interpolant $I$ for $(A, B)$ is a formula fulfilling the following characteristics:
		\begin{itemize}
			\item $A \Rightarrow I$
			\item $I \land B$ is unsatisfiable
			\item $I$ consists only of variables found in $A \cap B$
		\end{itemize}
	\end{mydef}

	\pagebreak
	
	%-------------------------------------------------%
	\section{PDR in Ultimate}
	%-------------------------------------------------%
	Describe how PDR works...
	
	
	%-------------------------------------------------%
	\section{Interprocedual PDR in Ultimate}
	%-------------------------------------------------%
	
		
	\begin{mydef}
		satisfiability checking with Hoare Triple checker and its specialties for call and return
	\end{mydef}
	
	What technique we used to implement interprocedual. (@ \textbf{Discussion of why we do it our way and showing why the other approaches do not work})What we have done to get our intraprocedual PDR to interprocedual.
	
	\section{Using Interpolants}
	How we make use of the interpolants, meaning showing that we strengthen the frames with an interpolant to cover more predecessor states. Example maybe
	
	\section{Evaluation}
	Run the benchmarks again and compare them to the ones from last year, where we will see (hopefully) a speedup.
	
	\pagebreak
	
\addcontentsline{toc}{chapter}{Bibliography}
\bibliographystyle{plain}
\bibliography{bib}

	
\end{document}